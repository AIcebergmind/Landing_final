<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aiceberg Mind - Hero</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<canvas id="particles-background"></canvas>

  <style>
    :root {
      --glacier-blue: #5EE4C3;
      --ice-cyan: #3AC8F5;
      --twilight: #a6c1ee;
      --deep-night: #0F2B3A;
      --frost-white: #F5F9FF;
    }

    body, html {
      margin: 0;
      padding: 0;
    font-family: "IBM Plex Sans", sans-serif;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    body {
  scroll-snap-type: y mandatory;
}
.horizontal-scroll-wrapper {
  scroll-snap-align: start;
  scroll-snap-stop: always;
}

  .ibm-plex-sans {
    font-family: "IBM Plex Sans", sans-serif;
    font-weight: 400;
    font-style: normal;
  }



/* === STILI GLOBALI TITOLI === */
h1 {
  font-size: clamp(2.8rem, 4vw, 2.8rem);
  font-weight: 700;
  line-height: 1.2;
  margin: 2rem 0;
  padding: 2rem 0;
  position: relative;
}

/* Linea wireframe sopra H1 */
h1::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

/* Linea wireframe sotto H1 */
h1::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

h2 {
  font-size: clamp(1.4rem, 3vw, 2.2rem);
  font-weight: 500;
  line-height: 1.3;
  margin: 0 0 1.5rem 0;
  text-transform: uppercase;
}

h3 {
  font-size: clamp(1.4rem, 3vw, 2.2rem);
  font-weight: 400;
  line-height: 1.4;
  margin: 0 0 1rem 0;
}

/* === STILE GLOBALE TAGLINE === */
.tagline {
  font-size: clamp(1.2rem, 3vw, 2rem);
  font-weight: 300;
  font-style: italic;
  line-height: 1.4;
  margin: 0 0 2rem 0;
  /* Il colore verr√† impostato dinamicamente dall'iceberg */
}

/* === STILI GLOBALI PARAGRAFI === */
p {
  font-size: 1rem;
  line-height: 1.7;
  margin: 0 0 1.5rem 0;
  color: #333;
}

/* Paragrafi su sfondi scuri */
.dark-bg p, 
section[style*="background: #"] p {
  color: #fff;
}


/* Paragrafi su sfondi chiari */
.light-bg p, 
section[style*="background: #"] p {
  color: #000000;
}



/* === FUNYIONI E MODULI GLOBALI ================ */

/* === ACCORDION RIUTILIZZABILE === */
.accordion {
  margin: 2rem 0;
  max-width: 800px;
}

.accordion-header {
  cursor: pointer;
  padding: 1rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
}

.accordion-header:hover {
  opacity: 0.8;
}

.accordion-content {
  overflow: hidden;
  transition: max-height 0.5s ease-out;
  max-height: 0;
}

.accordion.open .accordion-content {
  max-height: 800px; /* Regola in base al contenuto */
}

.accordion-text {
  padding: 1.5rem 0;
  line-height: 1.6;
}

/* === SEZIONI DINAMICHE PER ACCORDION === */
.parallax-section:has(.accordion.open) {
  height: auto !important;
  min-height: auto !important;
}

/* Assicura che tutti i contenitori si adattino al contenuto */
.section1, .section2, .section3, .section4 {
  height: auto !important;
  min-height: 100vh;
  margin: 0 !important; /* Nessun margin tra sezioni */
  padding: 0 !important; /* Nessun padding nelle sezioni stesse */
}


.read-more-container {
  max-width: 800px;
  margin: 2rem 0;
}

.read-more-preview {
  line-height: 1.6;
  margin-bottom: 1.5rem;
}

.read-more-content {
  overflow: hidden;
  transition: max-height 0.8s ease-out, opacity 0.6s ease-out;
  max-height: 0;
  opacity: 0;
}

.read-more-content.open {
  max-height: 1000px; /* Altezza sufficiente per tutto il contenuto */
  opacity: 1;
}

.read-more-text {
  line-height: 1.6;
  padding-top: 0.5rem;
}

.read-more-btn {
  background: transparent;
  border: 1px solid currentColor;
  color: inherit;
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-family: inherit;
}

.read-more-btn:hover {
  background: currentColor;
  color: #fff;
  transform: translateY(-2px);
}

/* === REGOLE RESPONSIVE SEMPLICI === */

/* DESKTOP: Solo breadcrumb, no menu */
@media (min-width: 769px) {
  .main-menu {
    display: none !important;
  }
  
  .breadcrumb-container {
    display: flex !important;
  }
}

/* MOBILE: Solo menu, no breadcrumb */
@media (max-width: 768px) {
  .breadcrumb-container {
    display: none !important;
  }
  
  .main-menu {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
  }
}

/* Responsive read more */
@media (max-width: 768px) {
  .read-more-container {
    margin: 1.5rem 0;
  }
  
  .read-more-btn {
    width: 100%;
    padding: 1rem;
  }
}

/* === DIVIDERS RIUTILIZZABILI === */
/* Divider semplice con linea */
.divider {
  margin: 3rem 0;
  text-align: center;
  position: relative;
}

.divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

/* Divider con simbolo al centro */
.divider-symbol {
  margin: 3rem 0;
  text-align: center;
  position: relative;
  font-size: 1.5rem;
  color: currentColor;
  opacity: 0.6;
}

.divider-symbol::before,
.divider-symbol::after {
  content: '';
  position: absolute;
  top: 50%;
  width: 30%;
  height: 1px;
  background: linear-gradient(90deg, transparent, currentColor, transparent);
  opacity: 0.3;
}

.divider-symbol::before {
  left: 0;
}

.divider-symbol::after {
  right: 0;
}

/* Divider wireframe (stile iceberg) */
.divider-wireframe {
  margin: 3rem 0;
  height: 40px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.divider-wireframe::before {
  content: '';
  position: absolute;
  width: 60px;
  height: 30px;
  border: 1px solid currentColor;
  border-radius: 50% 50% 0 0;
  opacity: 0.3;
  animation: float 3s ease-in-out infinite;
}

.divider-wireframe::after {
  content: '';
  position: absolute;
  top: 20px;
  width: 80px;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 30%, 
    currentColor 70%, 
    transparent 100%);
  opacity: 0.2;
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-3px); }
}

/* Divider dots */
.divider-dots {
  margin: 3rem 0;
  text-align: center;
}

.divider-dots::before {
  content: '‚Ä¢ ‚Ä¢ ‚Ä¢';
  font-size: 1.2rem;
  letter-spacing: 0.8rem;
  color: currentColor;
  opacity: 0.4;
}

/* Divider spacing variants */
.divider-sm { margin: 1.5rem 0; }
.divider-lg { margin: 4rem 0; }
.divider-xl { margin: 5rem 0; }

/* Responsive dividers */
@media (max-width: 768px) {
  .divider,
  .divider-symbol,
  .divider-wireframe,
  .divider-dots {
    margin: 2rem 0;
  }
  
  .divider-lg { margin: 2.5rem 0; }
  .divider-xl { margin: 3rem 0; }
}

/* === TOOLTIP RESPONSIVO === */
.tooltip {
  position: absolute;
  top: 120%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  color: #fff;
  padding: 0.8rem 1.2rem;
  border-radius: 0.8rem;
  font-size: 0.85rem;
  font-weight: 400;
  line-height: 1.4;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  z-index: 1000;
  pointer-events: none;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.tooltip::before {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-bottom-color: rgba(0, 0, 0, 0.9);
}

.color-toggle-btn:hover .tooltip {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(5px);
}

/* Responsive tooltip per mobile */
@media (max-width: 768px) {
  .tooltip {
    position: fixed;
    top: auto;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    white-space: normal;
    max-width: calc(100vw - 2rem);
    text-align: center;
    font-size: 0.8rem;
    padding: 0.6rem 1rem;
  }
  
  .tooltip::before {
    display: none;
  }
  
  .color-toggle-btn:hover .tooltip {
    transform: translateX(-50%) translateY(0);
  }
}






/* ========== MENU E PULSANTI ========== */

.main-menu {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: white;
  padding: 1rem 2rem;
  z-index: 100;
  transform: translateY(-100%);
  transition: transform 0.6s ease, opacity 0.3s ease, visibility 0.3s ease;
}

.main-menu.visible {
  transform: translateY(0);
}

.main-menu.visible-menu {
  visibility: visible !important;
  opacity: 1 !important;
  transform: translateY(0) !important;
}

#wordCanvas {
  width: 100%;
  height: 100%;
  display: block;
}

.wordcanvas {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  justify-content: center;
  align-items: center;
  padding: 1rem 2rem;
  background: transparent;
}

.word {
  font-size: clamp(1rem, 2vw, 3rem);
  cursor: pointer;
  color: var(--ice-cyan);
  transition: transform 0.3s ease;
  user-select: none;
}

.word:hover {
  transform: scale(1.2);
  color: var(--glacier-blue);
}


 @media (max-width: 768px) {
  /* === NASCONDI BREADCRUMB SU MOBILE === */
  .breadcrumb-container {
    display: none !important;
  }
  
  /* === MENU HAMBURGER RESPONSIVE === */
  .hamburger-menu {
    display: flex !important;
    background: rgba(255, 0, 0, 0.2); /* DEBUG: sfondo rosso per vedere se c'√® */
    border: 2px solid var(--glacier-blue);
  }
  
  .wordcanvas {
    justify-content: space-between;
    padding: 0.5rem 1rem;
  }
  
  .wordcanvas > .word {
    display: none; /* Nascondi le parole del menu normale */
  }
  
  .console-container {
    display: none; /* Nascondi la console nel menu principale */
  }
  
  .main-menu {
    height: 70px; /* Riduci altezza menu su mobile */
  }
  
  /* === DISABILITA PINGUINO SU MOBILE === */
  #penguin-canvas {
    display: none !important;
  }
  
  .console-container {
    margin-left: 0;
    margin-top: 1rem;
    padding: 1rem 1.5rem 0.8rem 1.5rem;
    border-radius: 6px;
  }
  
  .console-buttons {
    flex-direction: column;
    gap: 0.8rem;
  }
  
  .color-toggle-btn {
    margin: 0;
    width: 100%;
    text-align: center;
  }
  
  /* === DISABILITA SYSTEM PANEL SU MOBILE === */
  .system-panel {
    display: none !important;
  }
}






/* === PULSANTi === */
.color-toggle-btn {
  background: transparent;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.5rem 1rem;
  border-radius: 2rem;
  font-size: clamp(0.9rem, 1.5vw, 1.2rem);
  font-family: inherit;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: 0 0.5rem;
  position: relative;
  /* I colori verranno aggiornati dinamicamente dall'iceberg */
}

.color-toggle-btn:hover {
  /* Lo sfondo hover verr√† impostato dinamicamente */
  color: #fff;
  transform: scale(1.05);
}

.color-toggle-btn.frozen {
  background: #ff6b6b;
  border-color: #ff6b6b;
  color: #fff;
}

.color-toggle-btn.frozen:hover {
  background: #ff5252;
  border-color: #ff5252;
}

/* === CONSOLE CONTAINER === */
.console-container {
  position: relative;
  padding: 1.5rem 2rem 1.2rem 2rem;
  margin-left: 2rem;
  border: 2px solid var(--ice-cyan);
  border-radius: 8px;
  transition: all 0.3s ease;
}

.console-container:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.console-label {
  position: absolute;
  top: -12px;
  left: 20px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.15em;
  color: var(--ice-cyan);
  background: white;
  padding: 0 0.8rem;
  text-transform: uppercase;
}

.console-buttons {
  display: flex;
  gap: 1rem;
  align-items: center;
}

/* === CTA JOIN US === */
.join-us-cta {
  background: linear-gradient(135deg, var(--ice-cyan), #5dade2);
  border: none;
  color: white;
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  margin-left: 1.5rem;
  transition: all 0.3s ease;
  text-transform: uppercase;
  box-shadow: 0 4px 15px rgba(0, 174, 239, 0.3);
}

.join-us-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 174, 239, 0.4);
  background: linear-gradient(135deg, #5dade2, var(--ice-cyan));
}

/* CTA nascosta su mobile */
@media (max-width: 768px) {
  .join-us-cta {
    display: none;
  }
}

/* === SYSTEM PANEL === */
.system-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 380px;
  height: 100vh;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-left: 2px solid var(--ice-cyan);
  transition: right 0.4s ease;
  z-index: 500;
  overflow-y: auto;
}

.system-panel.open {
  right: 0;
}

.system-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem;
  border-bottom: 1px solid var(--ice-cyan);
  background: rgba(255, 255, 255, 0.8);
}

.system-panel-title {
  font-weight: 600;
  font-size: 1.1rem;
  color: var(--ice-cyan);
  letter-spacing: 0.1em;
}

.close-panel-btn {
  background: none;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.close-panel-btn:hover {
  background: var(--ice-cyan);
  color: white;
}

.system-panel-content {
  padding: 1.5rem;
}

.control-section {
  margin-bottom: 2rem;
}

.control-section h4 {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--deep-night);
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  border-bottom: 1px solid #eee;
  padding-bottom: 0.5rem;
}

.control-group {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8rem;
  margin-bottom: 1rem;
}

.system-btn {
  background: transparent;
  border: 1px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.system-btn:hover, .system-btn.active {
  background: var(--ice-cyan);
  color: white;
}

.slider-control {
  width: 100%;
  margin-bottom: 1rem;
}

.slider-control label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--deep-night);
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.slider-control input[type="range"] {
  width: 100%;
  accent-color: var(--ice-cyan);
  height: 4px;
}

.slider-control span {
  color: var(--ice-cyan);
  font-weight: 600;
}

/* === PULSANTE CLARITY === */
#clarityToggle {
  background: transparent;
  border: 2px solid #666;
  color: #666;
}

#clarityToggle:hover {
  background: #666;
  color: #fff;
  transform: scale(1.05);
}

#clarityToggle.active {
  background: #000;
  border-color: #000;
  color: #fff;
}

#clarityToggle.active:hover {
  background: #222;
  border-color: #222;
}

/* === MODALIT√Ä HIGH CONTRAST === */
body.high-contrast {
  background: #000 !important;
  color: #fff !important;
}

body.high-contrast .main-menu {
  background: #000 !important;
  color: #fff !important;
  border-bottom: 1px solid #333;
}

body.high-contrast .console-container {
  border-color: #fff !important;
}

body.high-contrast .console-label {
  color: #fff !important;
  background: #000 !important;
}

body.high-contrast .system-panel {
  background: rgba(0, 0, 0, 0.95) !important;
  border-left-color: #fff !important;
}

body.high-contrast .system-panel-header {
  background: rgba(0, 0, 0, 0.9) !important;
  border-bottom-color: #fff !important;
}

body.high-contrast .system-panel-title {
  color: #fff !important;
}

body.high-contrast .close-panel-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .close-panel-btn:hover {
  background: #fff !important;
  color: #000 !important;
}

body.high-contrast .control-section h4 {
  color: #fff !important;
  border-bottom-color: #333 !important;
}

body.high-contrast .system-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .system-btn:hover,
body.high-contrast .system-btn.active {
  background: #fff !important;
  color: #000 !important;
}

body.high-contrast .slider-control label {
  color: #fff !important;
}

body.high-contrast .slider-control span {
  color: #fff !important;
}

body.high-contrast section,
body.high-contrast .parallax-section {
  background: #000 !important;
  color: #fff !important;
}

body.high-contrast h1,
body.high-contrast h2,
body.high-contrast h3,
body.high-contrast p,
body.high-contrast .tagline,
body.high-contrast .intro-text {
  color: #fff !important;
}

body.high-contrast .word {
  color: #fff !important;
}

body.high-contrast .word:hover {
  color: #ccc !important;
}

body.high-contrast #iceberg {
  background: #000 !important;
}

body.high-contrast .hero-text {
  color: #fff !important;
}

/* === HIGH CONTRAST per MENU MOBILE === */
body.high-contrast .hamburger-line {
  background: #fff !important;
}

body.high-contrast .mobile-menu-overlay {
  background: rgba(0, 0, 0, 0.95) !important;
  border-left: 1px solid #fff;
}

body.high-contrast .mobile-nav-items .word {
  color: #fff !important;
  border-bottom-color: rgba(255, 255, 255, 0.2);
}

body.high-contrast .mobile-console-container {
  border-top-color: rgba(255, 255, 255, 0.2);
}

body.high-contrast .mobile-console-container .console-label {
  color: #fff !important;
}

body.high-contrast .mobile-console-container .color-toggle-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .mobile-console-container .color-toggle-btn:hover {
  background: #fff !important;
  color: #000 !important;
}

/* === MENU HAMBURGER === */
.hamburger-menu {
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 30px;
  height: 30px;
  cursor: pointer;
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 400;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border-radius: 50%;
  padding: 8px;
  border: 2px solid var(--ice-cyan);
  transition: all 0.3s ease;
}

.hamburger-menu:hover {
  background: var(--ice-cyan);
}

.hamburger-menu:hover .hamburger-line {
  background: #000;
}

/* Mostra hamburger solo su mobile quando breadcrumb √® nascosto */
@media (max-width: 768px) {
  .hamburger-menu {
    display: flex;
  }
}

.hamburger-line {
  width: 25px;
  height: 3px;
  background: var(--ice-cyan);
  margin: 3px 0;
  transition: all 0.3s ease;
  transform-origin: center;
}

.hamburger-menu.active .hamburger-line:nth-child(1) {
  transform: rotate(45deg) translate(6px, 6px);
}

.hamburger-menu.active .hamburger-line:nth-child(2) {
  opacity: 0;
}

.hamburger-menu.active .hamburger-line:nth-child(3) {
  transform: rotate(-45deg) translate(6px, -6px);
}

.mobile-menu-overlay {
  position: fixed;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100vh;
  background: rgba(176, 224, 230, 0.95); /* Glacier blue */
  backdrop-filter: blur(20px);
  z-index: 300;
  display: flex;
  flex-direction: column;
  padding-top: 80px;
  /* CSS transition per slide effect */
  transition: left 0.4s ease-in-out;
  /* Scroll abilitato */
  overflow-y: auto;
  overflow-x: hidden;
}

/* Scrollbar personalizzata per mobile menu */
.mobile-menu-overlay::-webkit-scrollbar {
  width: 4px;
}

.mobile-menu-overlay::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin: 80px 0 20px 0; /* Evita sovrapposizione con X e bordo inferiore */
}

.mobile-menu-overlay::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.4);
  border-radius: 2px;
  transition: background 0.3s ease;
}

.mobile-menu-overlay::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.6);
}

/* Per Firefox */
.mobile-menu-overlay {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.4) rgba(255, 255, 255, 0.1);
}

/* Scrollbar in modalit√† clarity */
body.high-contrast .mobile-menu-overlay::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.4);
}

body.high-contrast .mobile-menu-overlay::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.6);
}

body.high-contrast .mobile-menu-overlay {
  scrollbar-color: rgba(0, 0, 0, 0.4) rgba(255, 255, 255, 0.1);
}

.mobile-menu-overlay.open {
  left: 0;
}

/* X per chiudere il menu */
.mobile-close-btn {
  position: absolute;
  top: 20px;
  right: 20px;
  font-size: 1.8rem;
  font-weight: bold;
  color: white;
  cursor: pointer;
  z-index: 400;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: transparent;
  border: 2px solid rgba(176, 224, 230, 1); /* Bordo glacier blue */
  transition: all 0.3s ease;
}

.mobile-close-btn:hover {
  background: rgba(176, 224, 230, 0.2);
  transform: scale(1.1);
}

/* Modalit√† clarity - X nera */
body.high-contrast .mobile-close-btn {
  color: #000;
  border-color: rgba(176, 224, 230, 1);
}

body.high-contrast .mobile-close-btn:hover {
  background: rgba(176, 224, 230, 0.3);
}

.mobile-nav-items {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
  padding: 1.5rem 2rem;
  align-items: flex-end;
}

.mobile-nav-items .word {
  font-size: 1.2rem;
  text-align: right;
  padding: 0.6rem 0.8rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  width: auto;
}

.mobile-console-container {
  margin-top: 1.5rem;
  padding: 1.5rem 2rem;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  position: relative;
}

/* Fix per la label CONSOLE su mobile - posizionata dentro il container */
.mobile-console-container .console-label {
  position: relative !important;
  top: auto !important;
  left: auto !important;
  margin-bottom: 1rem;
  background: none !important;
  padding: 0 !important;
  font-size: 0.85rem;
  text-align: center;
}

.mobile-console-container .console-buttons {
  flex-direction: column;
  gap: 0.8rem;
}

.mobile-console-container .color-toggle-btn {
  width: 100%;
  padding: 0.8rem;
  font-size: 0.95rem;
}

/* === CTA JOIN US MOBILE === */
.mobile-cta-container {
  margin-top: 2rem;
  padding: 0 2rem 2rem 2rem; /* Aggiunto padding bottom per scroll */
  display: flex;
  justify-content: center;
}

.mobile-join-us-cta {
  background: linear-gradient(135deg, var(--ice-cyan), #5dade2);
  border: none;
  color: white;
  padding: 1rem 2rem;
  border-radius: 30px;
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  box-shadow: 0 4px 15px rgba(0, 174, 239, 0.4);
  width: 100%;
  max-width: 200px;
}

.mobile-join-us-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 174, 239, 0.5);
  background: linear-gradient(135deg, #5dade2, var(--ice-cyan));
}


/* === LAYOUT SEZIONI === */

/* Classe generale per sezioni */

    section {
      position: relative;
      min-height: 100vh; /* Cambiato da height a min-height per flessibilit√† */
      height: auto; /* Permette l'espansione in base al contenuto */
      display: flex;
      align-items: flex-start;
      justify-content: center;
      text-align: left;
      z-index: 6;
      padding: 2rem;
      width: 100%;
      box-sizing: border-box;
      flex-direction: column;
    }



/* === LAYOUT FLEXBOX  === */

/* Contenitore a 2 colonne */
.flex-2col {
  display: flex;
  gap: 3rem;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  align-items: center;
  height: auto; /* Altezza automatica basata sul contenuto */
  min-height: auto; /* Nessuna altezza minima */
}

.flex-2col > * {
  flex: 1; /* Ogni figlio prende la stessa larghezza */
}

/* Contenitore a larghezza piena */
.flex-full {
  max-width: 1200px;
  margin: 2rem auto;
  padding: 0 2rem;
  width: 100%;
  height: auto; /* Altezza automatica basata sul contenuto */
  min-height: auto; /* Nessuna altezza minima */
}

/* Responsive per mobile */
@media (max-width: 768px) {
  .flex-2col {
    flex-direction: column;
    gap: 2rem;
  }
}





   .parallax-section {
      text-align: left;
      display: block;
      padding: 1.5rem 2rem; /* Ridotto da 3rem a 1.5rem */
      margin-top: 0; /* Rimuove margin tra sezioni */
      z-index: 5;
      min-height: auto; /* Override min-height per sezioni parallax */
      height: auto; /* Altezza completamente flessibile */
      flex-direction: column; /* Per contenuti che si sviluppano verticalmente */
      overflow-x: hidden; /* üî• Evita scroll orizzontale nelle sezioni */
    }





    /* Responsive padding per sezioni */
    @media (max-width: 768px) {
      .parallax-section {
        padding: 1rem 1rem; /* Ridotto da 1.5rem a 1rem per ancora meno spazio */
        margin-top: 0; /* Nessun margin tra sezioni anche su mobile */
      }
    
    }

    .parallax-image {
      position: absolute;
      width: 60vw;
      max-width: 800px;
      z-index: 2;
      opacity: 0.2;
    }





.horizontal-scroll-wrapper {
  position: relative;
  height: 60vh; /* Ridotto da 100vh a 60vh per essere coerente con content */
    padding: 0 !important;
  margin: 0 !important;
  overflow: hidden;
}
.horizontal-scroll-content {
  position: relative;
  top: 0;
  left: 0;
  display: flex;
  width: max-content;
  height: 60vh; /* Ridotto da 100vh a 60vh */
  will-change: transform;
}

.card-scroll {
  min-width: 50vw; /* Ridotto da 60vw a 50vw */
  flex: 0 0 auto;
  margin-right: 1rem; /* Ridotto da 2rem a 1rem */
  display: flex;
  align-items: stretch;
}
.flex-2col-scroll {
  display: flex;
  flex-direction: row;
  gap: 1.5rem; /* Ridotto da 2rem a 1.5rem */
  width: 80%;
}
.card-title {
  flex: 0 0 180px; /* Ridotto da 220px a 180px */
  font-size: 1.6rem; /* Ridotto da 2rem a 1.6rem */
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: flex-start;
}
.card-content {
  flex: 1 1 auto;
  display: flex;
  align-items: center;
}

/* === SECTION HEADERS (GENERALE) === */
.section-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 0 2rem;
}

.section-title {
  font-size: 3.5rem;
  font-weight: 700;
  color: var(--ice-cyan);
  margin-bottom: 0.5rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.section-subtitle {
  font-size: 1.3rem;
  color: var(--glacier-blue);
  font-weight: 400;
  opacity: 0.9;
}

/* === PROJECTS SECTION === */
#projects {
  position: relative;
  min-height: 80vh; /* Ridotto da 100vh */
  padding: 0; /* Rimosso padding - usa quello di parallax-section */
  color: white;
}

#projects .parallax-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  overflow: hidden;
}

#projects .parallax-bg img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.3;
}

.projects-content {
  position: relative;
  z-index: 2;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.projects-wrapper {
  flex: 1;
  min-height: 400px;
}

.projects-grid {
  display: flex;
  gap: 2rem;
  padding: 0 2rem;
  align-items: center;
}

.project-card {
  min-width: 350px;
  width: 350px;
  height: 300px;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.project-card:hover {
  transform: translateY(-10px) scale(1.02);
  border-color: var(--ice-cyan);
  box-shadow: 0 20px 60px rgba(94, 228, 195, 0.2);
}

.project-card:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(94, 228, 195, 0.1), transparent);
  transition: left 0.6s ease;
}

.project-card:hover:before {
  left: 100%;
}

.project-header {
  margin-bottom: 2rem;
}

.project-title {
  font-size: 1.4rem;
  font-weight: 700;
  color: white;
  margin-bottom: 0.5rem;
  line-height: 1.3;
}

.project-subtitle {
  font-size: 0.95rem;
  color: var(--glacier-blue);
  font-weight: 400;
  opacity: 0.8;
  line-height: 1.4;
}

.project-progress {
  margin-bottom: 1.5rem;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--ice-cyan), var(--glacier-blue));
  border-radius: 3px;
  transition: width 0.8s ease;
  position: relative;
}

.progress-fill:after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: progressShine 2s infinite;
}

@keyframes progressShine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.progress-text {
  font-size: 0.8rem;
  color: var(--ice-cyan);
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.project-btn {
  background: transparent;
  border: 2px solid var(--glacier-blue);
  color: var(--glacier-blue);
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  align-self: flex-start;
}

.project-btn:hover {
  background: var(--glacier-blue);
  color: #000;
  transform: translateX(5px);
}

/* Responsive Projects */
@media (max-width: 768px) {
  #projects {
    padding: 0; /* Nessun padding aggiuntivo - usa solo parallax-section */
    min-height: 60vh; /* Ridotto anche per mobile */
  }
  
  /* Section Headers Responsive (generale) */
  .section-title {
    font-size: 2.2rem; /* Ridotto da 3.5rem */
  }
  
  .section-subtitle {
    font-size: 1rem; /* Ridotto da 1.3rem */
  }
  
  .section-header {
    margin-bottom: 1rem; /* Ridotto spacing su mobile */
    padding: 0 1rem; /* Ridotto padding laterale */
  }
  
  .projects-wrapper {
    height: auto;
    overflow-x: auto;
    overflow-y: hidden;
  }
  
  .projects-grid {
    flex-direction: row;
    flex-wrap: nowrap;
    padding: 0 1rem;
  }
  
  .project-card {
    min-width: 280px;
    width: 280px;
    height: 250px;
    padding: 1.5rem;
  }
  
  .project-title {
    font-size: 1.2rem;
  }
  
  .project-subtitle {
    font-size: 0.85rem;
  }
}




    /* Override per immagini parallax nel flex */

    .flex-2col .parallax-image,
    .flex-full .parallax-image {
      position: relative;
      width: 100%;
      max-width: 100%;
      height: auto;
      opacity: 0.2;
      transform: translateY(20px) scale(0.5); /* Parte da met√† scala */
      transition: opacity 1.5s ease-out, transform 1.5s ease-out;
      transform-origin: center center; /* Zoom dal centro */
    }

    /* Stato visibile quando in vista */
    .flex-2col .parallax-image.in-view,
    .flex-full .parallax-image.in-view {
      opacity: 1;
      transform: translateY(0) scale(0.8); /* Si sviluppa all'80% */
    }

    .parallax-text {
      z-index: 2;
      font-size: 2rem;
      max-width: 60vw;
    }

/* === RIDUZIONE SPAZIO TRA SEZIONI === */
#about {
  padding-bottom: 0.5rem; /* Riduce padding-bottom specifico per ABOUT */
  padding-top:100px; /* Compensazione per breadcrumb fisso (60px + margine) */
}

#projects {
  padding-top: 0.5rem; /* Riduce padding-top specifico per PROJECTS */
}

/* Mobile: ancora meno spazio */
@media (max-width: 768px) {
  #about {
    padding-bottom: 0.25rem;
  }
  
  #projects {
    padding-top: 0.25rem;
  }
}

/* === RESPONSIVE PARALLAX IMAGES === */
@media (max-width: 768px) {
  /* Su mobile: immagini parallax centrate e non sovrapposte */
  .flex-2col .parallax-image,
  .flex-full .parallax-image {
    display: block;
    margin: 2rem auto; /* Centrate con margin */
    max-width: calc(100% - 4rem); /* Rispetta il padding del sito */
    width: auto;
    height: auto;
    position: relative;
    transform: translateY(20px) scale(0.6); /* Pi√π piccole su mobile */
  }
  
  .flex-2col .parallax-image.in-view,
  .flex-full .parallax-image.in-view {
    transform: translateY(0) scale(0.7); /* Scale finale pi√π contenuta su mobile */
  }
  
  /* Contenitori flex-2col su mobile diventano colonna */
  .flex-2col {
    flex-direction: column;
    gap: 3rem; /* Pi√π spazio tra contenuto e immagine */
  }
  
  /* Ordine degli elementi su mobile */
  .flex-2col .parallax-image {
    order: 2; /* Immagine dopo il contenuto */
  }
  
  .flex-2col .content-column {
    order: 1; /* Contenuto prima */
  }
}



  /* PRELOADER*/

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #333;
  border-top-color: #fff;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.logo {
  transition: opacity 0.3s ease, transform 0.3s ease;
  opacity: 1;
}


#preloader {
  position: fixed;
  inset: 0;
  background: linear-gradient(to bottom, #fff 0%, #000 100%);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  transition: opacity 0.6s ease;
}

#preloader.fade-out {
  opacity: 0;
  pointer-events: none;
}

.preloader-controls {
  margin-top: 2rem;
  padding: 2rem 2.5rem;
  box-shadow: 0 4px 32px rgba(255, 255, 255, 0.1);
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  align-items: center;
}

.preloader-controls label {
  color: #ffffff;
  font-size: 1.1rem;
  font-weight: 500;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.3rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.preloader-controls input[type="range"] {
  width: 200px;
  accent-color: var(--glacier-blue);
  margin-top: 0.5rem;
  height: 4px;
}

.preloader-controls span {
  margin-left: 0.5rem;
  font-weight: bold;
  color: #ffffff;
  font-size: 1.1rem;
}

#startBtn {
  margin-top: 1rem;
  padding: 0.7rem 2.2rem;
  background: transparent;
  color: #ffffff;
  border: 2px solid #000;
  border-radius: 4px;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

#startBtn:hover {
  background: #000;
  color: #fff;
}

@media (max-width: 600px) {
  .preloader-controls {
    padding: 1.2rem 1rem;
    width: 90vw;
  }
  .preloader-controls input[type="range"] {
    width: 120px;
  }
}


#preloader .preloader-logo {
  width: 160px;
  max-width: 30vw;
  margin-bottom: 2rem;
  opacity: 1;
  transform: scale(1);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

#preloader .preloader-logo img {
  width: 100%;
  height: auto;
  display: block;
}










/* ICEBERG E PINGUINO */

#iceberg {
  width: 100%;
  height: 100%;
  display: block;
  transform-origin: center center;
  background-color: #2b2d42; /* fallback se il canvas non disegna subito */
}

#penguin-canvas {
  width: 400px;     
  height: auto;
  position: fixed;
  bottom: 40px;
  right: 40px;
  z-index: 300;
   cursor: grab;
}

#penguin-canvas.dragging {
  cursor: grabbing;
}




/* GLOBAL EFFECT */

    #particles-background {
        position: fixed;
        top: 0;
        left: 0;
  width: 100vw;
  height: 100vh;
        z-index: 15;
      pointer-events: none;      
  background: transparent;
    }











/* HERO E SUBHERO */





.hero {
  position: relative;
  width: 100vw;
  height: 100vh;
  z-index:10;
  padding: 0;
  margin: 0;
          display: flex; /* da qui propeita section */
      align-items: flex-start;
      justify-content: center;
      text-align: left;
      z-index: 6;
      width: 100%;
      box-sizing: border-box;
      flex-direction: column;

}
.hero-text {
  position: absolute;
  z-index: 10;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  font-weight: normal;
  color: white;
  line-height: 2;
  transition: opacity 1s ease, transform 1s ease, color 0.8s ease;
}

.hero-text-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  pointer-events: none;
}


.hero-titles-wrapper {
  position: absolute;
  bottom: -120px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 5;
  text-align: center;
  opacity: 0;
  pointer-events: none;
}


.horizon-line {
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 4.5px;
  background: linear-gradient(to right, rgba(255,255,255,0.2), rgba(90,220,255,0.5), rgba(255,255,255,0.2));
  z-index: 1;
  pointer-events: none;
}

.scroll-indicator {
  position: absolute;
  top: 50%;
  right: 100px;
  transform: translateY(-50%);
  height: 250px;
  width: 4px;
  background-color: #222; /* linea verticale */
  z-index: 20;
  opacity: 0.6;
}

.scroll-text {
  position: absolute;
  right: 15px;
  top: 50%;
  transform-origin: right center;
  font-size: 20px;
  letter-spacing: 0.1em;
  color: #222;
  opacity: 0.8;
  pointer-events: none;
  user-select: none;
}

.scroll-box {
  position: absolute;
  top: 0;
  left: -6px;
  width: 14px;
  height: 14px;
  background-color: #5EE4C3; /* rettangolino animato */
  border-radius: 3px;
  animation: scrollDown 2.5s infinite ease-in-out;
}

@keyframes scrollDown {
  0%   { top: 0; opacity: 1; }
  50%  { top: 250px; opacity: 0.4; }
  100% { top: 0; opacity: 1; }
}

/* === HERO CTA === */
.hero-cta {
  position: absolute;
  bottom: 60px;
  right: 60px;
  z-index: 25;
  opacity: 0;
  visibility: hidden;
  transform: translateY(20px);
  transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  display: none; /* Nascosta ora che usiamo quella nella SUBHERO */
}

.hero-cta.visible {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.hero-join-btn {
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border: 2px solid var(--ice-cyan, #5EE4C3);
  color: var(--ice-cyan, #5EE4C3);
  padding: 1rem 2rem;
  border-radius: 50px;
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 8px 32px rgba(94, 228, 195, 0.2);
  position: relative;
  overflow: hidden;
}

.hero-join-btn:hover {
  background: var(--ice-cyan, #5EE4C3);
  color: #000;
  transform: translateY(-2px);
  box-shadow: 0 12px 40px rgba(94, 228, 195, 0.4);
}

.hero-join-btn:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: left 0.5s;
}

.hero-join-btn:hover:before {
  left: 100%;
}

/* Responsive Hero CTA */
@media (max-width: 768px) {
  .hero-cta {
    bottom: 40px;
    right: 20px;
    left: 20px;
    text-align: center;
  }
  
  .hero-join-btn {
    width: 100%;
    max-width: 200px;
    padding: 0.8rem 1.5rem;
    font-size: 0.9rem;
  }
}





/* === SUBHERO -=== */
.subhero {
  /* background now handled by body for global effect */
  color: #fff;
  padding: 1.5rem 1.5rem 2.5rem 1.5rem; /* Aggiunto padding-bottom maggiore */
  margin: 0;
  width: 100%;
  min-height: 80vh; /* Aumentato per consistenza con altre sezioni */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  z-index: 1;
  opacity: 1;
  font-size: 1.2rem;
  text-align: center;
  border: none;
  box-shadow: 0 8px 32px rgba(58,200,245,0.08);
}

.subhero-container {
  color: #fff;
}

.subhero-title {
  color: var(--ice-cyan);
  transition: color 0.5s;
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
}

.subhero-subtitle {
  color: var(--glacier-blue);
  transition: color 0.5s;
  font-size: 1.2rem;
  font-weight: 400;
  margin-bottom: 0;
}

/* === SUBHERO CTA === */
.subhero-cta {
  margin-top: 2.5rem;
  text-align: center;
  position: relative;
}

.cta-divider {
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--ice-cyan), transparent);
  margin: 0 auto 1.5rem auto;
  border-radius: 1px;
}

.subhero-cta-text {
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.1rem;
  font-weight: 500;
  margin-bottom: 2rem;
  line-height: 1.5;
  letter-spacing: 0.05em;
  font-style: italic;
}

.subhero-join-btn {
  background: linear-gradient(135deg, rgba(94, 228, 195, 0.1), rgba(94, 228, 195, 0.05));
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 1.2rem 3rem;
  border-radius: 50px;
  font-size: 1.1rem;
  font-weight: 700;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  box-shadow: 
    0 4px 20px rgba(94, 228, 195, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  display: inline-flex;
  align-items: center;
  gap: 0.8rem;
}

/* Desktop: wider border */
@media (min-width: 768px) {
  .subhero-join-btn {
    border-width: 3px;
  }
}

.btn-icon {
  font-size: 1.2rem;
  opacity: 0.8;
  transition: all 0.3s ease;
}

.btn-arrow {
  font-size: 1rem;
  opacity: 0.7;
  transition: all 0.3s ease;
  transform: translateX(0);
}

.subhero-join-btn:hover {
  background: linear-gradient(135deg, var(--ice-cyan), rgba(94, 228, 195, 0.9));
  color: #000;
  transform: translateY(-4px) scale(1.02);
  box-shadow: 
    0 12px 35px rgba(94, 228, 195, 0.4),
    0 0 30px rgba(94, 228, 195, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.subhero-join-btn:hover .btn-icon {
  opacity: 1;
  transform: scale(1.1);
}

.subhero-join-btn:hover .btn-arrow {
  opacity: 1;
  transform: translateX(3px);
}

.subhero-join-btn:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  transition: left 0.6s;
}

.subhero-join-btn:hover:before {
  left: 100%;
}

/* Effetto pulsante */
.subhero-join-btn:after {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border-radius: 50px;
  background: linear-gradient(45deg, var(--ice-cyan), var(--glacier-blue), var(--ice-cyan));
  z-index: -1;
  opacity: 0;
  transition: opacity 0.3s ease;
  animation: borderPulse 2s infinite;
}

.subhero-join-btn:hover:after {
  opacity: 0.6;
}

@keyframes borderPulse {
  0%, 100% { transform: scale(1); opacity: 0.3; }
  50% { transform: scale(1.05); opacity: 0.1; }
}

  .dynamic-border {
    display: inline-block;
    padding: 1.5em 3.8rem;
    border: 3px solid var(--ice-cyan, #5EE4C3);
    border-radius: 2.5em;
    transition: border-color 0.6s cubic-bezier(.4,0,.2,1);
    box-sizing: border-box;
  }

/* === BREADCRUMB PROGRESS BAR === */
.breadcrumb-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(20px);
  z-index: 400;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 2rem;
  box-sizing: border-box;
  transition: all 0.3s ease;
}

.breadcrumb-progress {
  position: absolute;
  top: 0;
  left: 0;
  height: 3px;
  background: var(--ice-cyan);
  width: 0%;
  transition: width 0.3s ease;
}

.breadcrumb-sections {
  display: flex;
  gap: 3rem;
  align-items: center;
}

.breadcrumb-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 0.6;
  position: relative;
}

.breadcrumb-item.active {
  opacity: 1;
}

.breadcrumb-dot {
  display: none; /* Nasconde i pallini */
}

.breadcrumb-label {
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  color: white;
  text-transform: uppercase;
  transition: all 0.3s ease;
  position: relative;
}

.breadcrumb-item.active .breadcrumb-label {
  font-weight: 700;
  font-size: 0.8rem;
  color: var(--glacier-blue);
  transform: translateY(-2px);
}

.breadcrumb-item .breadcrumb-label:after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 2px;
  background: var(--glacier-blue);
  transition: width 0.3s ease;
}

.breadcrumb-item.active .breadcrumb-label:after {
  width: 100%;
}

.breadcrumb-item:hover {
  opacity: 1;
  transform: translateY(-2px);
}

.breadcrumb-item:hover .breadcrumb-label:after {
  width: 60%;
}

/* Responsive breadcrumb */
@media (max-width: 768px) {
  .breadcrumb-container {
    height: 50px;
    padding: 0 1rem;
    /* Nasconde breadcrumb su mobile */
    display: none;
  }
  
  .breadcrumb-sections {
    gap: 1.5rem;
  }
  
  .breadcrumb-label {
    font-size: 0.6rem;
  }
  
  .breadcrumb-item.active .breadcrumb-label {
    font-size: 0.7rem;
  }
}

/* === CONSOLE TOGGLE IN BREADCRUMB === */
.breadcrumb-console-toggle {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 1;
  margin-left: auto;
  padding-left: 2rem;
  border-left: 2px solid var(--glacier-blue);
  position: relative;
}

.breadcrumb-console-toggle:hover {
  transform: translateY(-2px);
}

.console-label {
  font-size: 0.7rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: var(--glacier-blue);
  text-transform: uppercase;
  line-height: 1;
  margin: 0;
  padding: 0;
  display: inline-block;
  vertical-align: middle;
}

.console-arrow {
  font-size: 0.6rem;
  color: var(--glacier-blue);
  transition: transform 0.3s ease;
  font-weight: bold;
  line-height: 1;
  margin: 0;
  padding: 0;
  display: inline-block;
  vertical-align: middle;
}

.breadcrumb-console-toggle.active .console-arrow {
  transform: rotate(180deg);
}

/* === CONSOLE PANEL === */
.console-panel {
  position: absolute;
  top: 100%;
  right: 2rem;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(20px);
  border-radius: 12px;
  padding: 1rem;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 300;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.console-panel.open {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.console-buttons {
  display: flex;
  gap: 0.8rem;
  flex-wrap: wrap;
}

.console-btn {
  background: transparent;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.6rem 1.2rem;
  border-radius: 25px;
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  white-space: nowrap;
}

.console-btn:hover {
  background: var(--ice-cyan);
  color: #000;
  transform: translateY(-2px);
}

.console-btn.frozen {
  border-color: #ff6b6b;
  color: #ff6b6b;
}

.console-btn.frozen:hover {
  background: #ff6b6b;
  color: white;
}

.console-btn.active {
  background: var(--glacier-blue);
  color: #000;
  border-color: var(--glacier-blue);
}

/* Tooltip per console buttons */
.console-btn .tooltip {
  position: absolute;
  bottom: 140%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.95);
  color: white;
  padding: 0.8rem 1rem;
  border-radius: 8px;
  font-size: 0.75rem;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  z-index: 1000;
  border: 1px solid rgba(255, 255, 255, 0.2);
  pointer-events: none;
  min-width: 200px;
  text-align: center;
  line-height: 1.4;
}

.console-btn .tooltip:before {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: rgba(0, 0, 0, 0.95);
}

.console-btn:hover .tooltip {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(-8px);
}

/* Responsive SubHero */
@media (max-width: 768px) {
  .subhero {
    min-height: 60vh; /* Aumentato per consistenza con ABOUT mobile */
    padding: 2rem 1rem 3rem 1rem; /* Aumentato padding-bottom anche su mobile */
    font-size: 1rem;
  }
  .subhero-title {
    font-size: 1.5rem;
  }
  .subhero-subtitle {
    font-size: 1rem;
  }
  
  /* Subhero CTA Responsive */
  .subhero-cta {
    margin-top: 2rem;
  }
  
  .cta-divider {
    width: 40px;
    margin-bottom: 1rem;
  }
  
  .subhero-cta-text {
    font-size: 1rem;
    margin-bottom: 1.5rem;
    padding: 0 1rem;
    line-height: 1.4;
  }
  
  .subhero-join-btn {
    padding: 1rem 2.5rem;
    font-size: 1rem;
    gap: 0.6rem;
    width: auto;
    max-width: 280px;
  }
  
  .btn-icon {
    font-size: 1.1rem;
  }
  
  .btn-arrow {
    font-size: 0.9rem;
  }
}


@media (max-width: 768px) {
  
  .hero-titles-wrapper {
    position: fixed !important; /* Usa fixed invece di absolute su mobile */
    bottom: 20vh !important; /* Posiziona i titoli nel 20% inferiore dello schermo */
    left: 50% !important;
    transform: translateX(-50%) !important;
    z-index: 15 !important; /* Sopra l'iceberg che ha z-index 10 */
    width: 90% !important; /* Limita la larghezza per mobile */
  }
  
  .hero-h1, .hero-h2, .hero-h3 {
    font-size: clamp(1.5rem, 4vw, 3rem); /* Responsive font size */
  }
  }


 





  </style>

</head>




















<body>
  <canvas id="penguin-canvas" width="1000" height="1000"></canvas>
<div id="preloader">
<div class="logo logotype preloader-logo">
  <img src="images/logo/logotext.svg" alt="Logo">
</div>

<div class="spinner"></div>
<p style="color: white; font-size: 1.1rem; margin-bottom: 1rem; text-align: center;">
  Craft your iceberg before diving in
</p>
  <div class="preloader-controls">
    <label>
      Nodes
      <input type="range" id="nodesRange" min="15" max="300" value="15">
      <span id="nodesValue">15</span>
    </label>
    <label>
      Line Distance
      <input type="range" id="distanceRange" min="250" max="550" value="200">
      <span id="distanceValue">200</span>
    </label>
    <button id="startBtn">DIVE IN</button>

  </div>
  
</div>
  <canvas id="particles-background"></canvas>

<!-- Breadcrumb Progress Bar -->
<div class="breadcrumb-container" id="breadcrumbContainer">
  <div class="breadcrumb-progress" id="breadcrumbProgress"></div>
  <div class="breadcrumb-sections">
    <div class="breadcrumb-item active" data-section="hero">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">HOME</span>
    </div>
    <div class="breadcrumb-item" data-section="about">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">ABOUT</span>
    </div>
    <div class="breadcrumb-item" data-section="projects">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">PROJECTS</span>
    </div>
    <div class="breadcrumb-item" data-section="team">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">TEAM</span>
    </div>
    <!-- Console Menu Toggle -->
    <div class="breadcrumb-console-toggle" id="consoleToggle">
      <span class="console-label">CONSOLE</span>
      <span class="console-arrow">‚ñº</span>
    </div>
  </div>
  
  <!-- Console Panel Expandable -->
  <div class="console-panel" id="consolePanel">
    <div class="console-buttons">
      <button id="breadcrumbColorToggle" class="console-btn">
        SYNAPSE
        <div class="tooltip">
          Controls the iceberg's dynamic color palette.<br>
          <strong>SYNAPSE</strong> ‚Üí <strong>FOCUS</strong> ‚Üí <strong>LET IT FLOW</strong>
        </div>
      </button>
      <button id="breadcrumbClarityToggle" class="console-btn">
        CLARITY
        <div class="tooltip">
          High contrast mode for better readability.<br>
          Black background with white text.
        </div>
      </button>
      <button id="breadcrumbSystemToggle" class="console-btn">
        SYSTEM
        <div class="tooltip">
          Advanced controls panel.<br>
          Developer tools, user preferences, and system settings.
        </div>
      </button>
    </div>
  </div>
</div>

<header class="main-menu">
  <nav>
    <div class="wordcanvas">
      <span class="word" data-target="ABOUT">ABOUT</span>
      <span class="word" data-target="PROJECTS">PROJECTS</span>
      <span class="word" data-target="#BLOG">BLOG</span>
      <span class="word" data-target="TEAM">TEAM</span>
      
      <div class="console-container">
        <div class="console-label">CONSOLE</div>
        <div class="console-buttons">
          <button id="colorToggle" class="color-toggle-btn">
            SYNAPSE
            <div class="tooltip">
              Controls the iceberg's dynamic color palette.<br>
              <strong>SYNAPSE</strong> ‚Üí <strong>FOCUS</strong> ‚Üí <strong>LET IT FLOW</strong>
            </div>
          </button>
          <button id="clarityToggle" class="color-toggle-btn">
            CLARITY
            <div class="tooltip">
              High contrast mode for better readability.<br>
              Black background with white text.
            </div>
          </button>
          <button id="systemToggle" class="color-toggle-btn">
            SYSTEM
            <div class="tooltip">
              Advanced controls panel.<br>
              Developer tools, user preferences, and system settings.
            </div>
          </button>
        </div>
      </div>
      
      <!-- CTA JOIN US -->
      <button class="join-us-cta" id="joinUsCta">JOIN US</button>
      
      <!-- Menu Hamburger (visibile solo su mobile) -->
      <div class="hamburger-menu" id="hamburgerMenu">
        <div class="hamburger-line"></div>
        <div class="hamburger-line"></div>
        <div class="hamburger-line"></div>
      </div>
    </div>

      <!-- Advanced System Panel -->
      <div id="systemPanel" class="system-panel">
        <div class="system-panel-header">
          <span class="system-panel-title">SYSTEM CONTROLS</span>
          <button id="closePanelBtn" class="close-panel-btn">√ó</button>
        </div>
        
        <div class="system-panel-content">
          <!-- Content Management -->
          <div class="control-section">
            <h4>Content Management</h4>
            <div class="control-group">
              <button class="system-btn" id="editBtn">EDIT</button>
              <button class="system-btn" id="previewBtn">PREVIEW</button>
              <button class="system-btn" id="publishBtn">PUBLISH</button>
            </div>
          </div>

          <!-- Developer Tools -->
          <div class="control-section">
            <h4>Developer Tools</h4>
            <div class="control-group">
              <button class="system-btn" id="debugBtn">DEBUG</button>
              <button class="system-btn" id="gridBtn">GRID</button>
              <button class="system-btn" id="traceBtn">TRACE</button>
            </div>
          </div>

          <!-- User Preferences -->
          <div class="control-section">
            <h4>User Preferences</h4>
            <div class="control-group">
              <div class="slider-control">
                <label for="flowSlider">FLOW <span id="flowValue">Normal</span></label>
                <input type="range" id="flowSlider" min="1" max="3" value="2">
              </div>
              <div class="slider-control">
                <label for="depthSlider">DEPTH <span id="depthValue">15</span></label>
                <input type="range" id="depthSlider" min="15" max="300" value="15">
              </div>
              <div class="slider-control">
                <label for="neuralSlider">NEURAL <span id="neuralValue">On</span></label>
                <input type="range" id="neuralSlider" min="0" max="1" value="1">
              </div>
            </div>
            <div class="control-group">
              <button class="system-btn" id="profileBtn">PROFILE</button>
              <button class="system-btn" id="resetBtn">RESET</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>

<!-- Menu Mobile Overlay -->
<div class="mobile-menu-overlay" id="mobileMenuOverlay">
  <!-- X per chiudere il menu -->
  <div class="mobile-close-btn" id="mobileCloseBtn">√ó</div>
  
  <div class="mobile-nav-items">
    <span class="word" data-target="ABOUT">ABOUT</span>
    <span class="word" data-target="PROJECTS">PROJECTS</span>
    <span class="word" data-target="#BLOG">BLOG</span>
    <span class="word" data-target="TEAM">TEAM</span>
  </div>
  
  <div class="mobile-console-container">
    <div class="console-label">CONSOLE</div>
    <div class="console-buttons">
      <button id="mobileColorToggle" class="color-toggle-btn">
        SYNAPSE
      </button>
      <button id="mobileClarityToggle" class="color-toggle-btn">
        CLARITY
      </button>
      <!-- SYSTEM button rimosso su mobile -->
    </div>
  </div>
  
  <!-- CTA JOIN US per mobile -->
  <div class="mobile-cta-container">
    <button class="mobile-join-us-cta" id="mobileJoinUsCta">JOIN US</button>
  </div>
</div>



  <class="hero" id="hero">
    <canvas id="iceberg" class="hero-canvas"></canvas>
  <div class="hero-text-wrapper">
<div class="hero-text-wrapper">
  <div class="hero-text text-compose mobile-no-text-compose">DEPTH<br>is not a feature. is our<br>NATURE</div>
  <div class="hero-text text-compose mobile-no-text-compose"><strong>AI</strong>CEBERG<br>MIND</div>
</div>

    <div class="horizon-line"></div>
    <div class="scroll-indicator">
      <div class="scroll-box"></div>
      <div class="scroll-text">DIVE IN</div>
    </div>
    
    <!-- CTA JOIN US in Hero -->
    <div class="hero-cta" id="heroCta">
      <button class="hero-join-btn">JOIN US</button>
    </div>
</div>


<!-- SubHero Section -->
<section class="parallax-section subhero" id="subhero">
<div class="subhero-container">
  <div class="dynamic-border">
    <h2 class="subhero-title text-compose mobile-no-text-compose">
      <strong>EMPOWERING HUMANS</strong>
    </h2>
    <h3 class="subhero-subtitle text-compose mobile-no-text-compose">
      through playful education, creative content<br>
      Inspired by science, crafted by AI
    </h3>
    
    <!-- CTA Section -->
    <div class="subhero-cta">
      <div class="cta-divider"></div>
      <p class="subhero-cta-text">What lies beneath the surface of your thinking?</p>
      <button class="subhero-join-btn">
        DIVE DEEPER
        <span class="btn-arrow">‚Üí</span>
      </button>
    </div>
  </div>
</div>
</section>


<!-- ABOUT -->
<section class="parallax-section" id="about">
  <!-- Header -->
  <div class="section-header">
    <h2 class="section-title text-compose">BEHIND THE SURFACE</h2>
    <p class="section-subtitle text-compose">Where depth meets discovery, and thinking becomes an art</p>
  </div>

  <div class="flex-2col">
    <div class="content-column">
      <h1 class>AIceberg Mind is a deep dive into the joy of discovery and the beauty of thinking.</h1>
      <h2 class="parallax-text">from the earliest spark to the lifelong wonder of the mind.</h2>
    </div>
    <div class="image-column">
      <img src="images/image_placeholder_about.png" alt="Img 1" class="parallax-image image1" />
    </div>
  </div>

  <div class="flex-full">
    <h3 class="parallax-text">
      It's a space where science meets imagination, where learning becomes play, and where artificial intelligence helps reveal what lies beneath <br>
      the surface ‚Äî <strong>not by teaching what to think, but by opening paths to think differently</strong>.
    </h3>
    <div class="divider-dots"></div>

    <!-- Manifesto con Read More -->
    <h3 class="text-compose parallax-text"><strong>- a short manifesto</strong></h3>

    <div class="read-more-container" id="readMoreSection">
      <!-- Testo preview sempre visibile (prime tre righe) -->
      <p class="read-more-preview">
        AIceberg Mind was born from a simple belief: that intelligence is not a race to the top, but a journey below the surface. In a world flooded with fast content and noisy knowledge, we wanted to create something different.<br><br>

        We see content not as a product, but as a living experience ‚Äî one that can play, teach, surprise, and empower. We create digital objects: some playful, some poetic, some purely practical.<br><br>

        We don't claim expertise in psychology or nervous system science. What we claim is curiosity in subconscious rewiring, craftsmanship, and care.
      </p>

      <!-- Contenuto completo nascosto inizialmente -->
      <div class="read-more-content"  id="readMoreContent">
        <p class="read-more-text">
          We are designers, makers, researchers, and parents ‚Äî trying to shape tools that spark ideas, facilitate creation, or gently awaken minds.<br><br>

          Some of our content is designed for children. Some for adults. Some for both. But all of it is guided by the same principle: explore below the surface. Education is not always the goal ‚Äî but it's often the side effect. And so is joy.<br><br>

          Inspired by the iceberg, our craft is layered: playful on the surface, rooted in research below. We use AI to enhance form and interaction, but never to replace thought.<br><br>

          Our vision begins in early childhood, where so much is silently shaped ‚Äî but it doesn't end there. It reaches the child within us all, the parents who guide, the educators who nurture, and the minds that still wonder.<br><br>

          AIceberg Mind is not an answer. It's a question: what kind of world do we create when we shape content from the depth of human potential?
        </p>
      </div>

      <!-- Pulsante Read More -->
      <button class="read-more-btn" id="readMoreBtn">
        <span class="read-more-text">Read more</span>
        <span class="read-less-text" style="display: none;">Read less</span>
      </button>
    </div>
  </div>

  <!-- Vision and Co -->
<div class="horizontal-scroll-wrapper" id="about-cards">
  <div class="horizontal-scroll-content">

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Vision</div>
        <div class="card-content parallax-text">
          <p>Our vision is to shape content that inspires curiosity, reflection, and wonder ‚Äî creating tools that help people think deeply, not just quickly. We believe that in a world of fast answers, slow thinking is radical.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Mission</div>
        <div class="card-content parallax-text">
          <p>Our mission is to create tools, objects, and experiences that stimulate creative thinking and emotional engagement. We make content that opens doors, not boxes ‚Äî playful in form, purposeful in intent.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Approach</div>
        <div class="card-content parallax-text">
          <p>We follow a design-driven, research-inspired process rooted in play and purpose. We mix cognitive science, storytelling, and interactivity ‚Äî always experimenting, always questioning, never boring.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">The AIceberg Method</div>
        <div class="card-content parallax-text">
          <p>Our method is layered: intuitive on the surface, rigorous underneath. Just like an iceberg, most of the structure is hidden ‚Äî what you see is playful, what you uncover is deep. We reveal how things work, not just what they are.</p>
        </div>
      </div>
    </div>

  </div>
 </div>
</section>

<!-- PROJECTS -->
<section class="parallax-section" id="projects">
  <div class="parallax-bg">
    <img src="images/projects-bg.jpg" alt="Projects Background" class="parallax-image" />
  </div>
  
  <div class="projects-content">
    <!-- Header -->
    <div class="section-header">
      <h2 class="section-title text-compose">OUR LIVING PROJECTS</h2>
      <p class="section-subtitle text-compose">Each project is a seed: interactive, alive.</p>
    </div>
    
    <!-- Horizontal Scroll Container -->
    <div class="horizontal-scroll-wrapper projects-wrapper">
      <div class="horizontal-scroll-content projects-grid">
        
        <!-- Project Card 1: Audio Rituals -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Audio Rituals</h3>
            <p class="project-subtitle">Evening hypnosis for deep rest</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 60%"></div>
            </div>
            <span class="progress-text">60% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
        <!-- Project Card 2: Nursery Rhymes -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Nursery Rhymes</h3>
            <p class="project-subtitle">Educational rhymes with Lumi & Nova</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 50%"></div>
            </div>
            <span class="progress-text">50% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
        <!-- Project Card 3: Specialized Channels -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Specialized Channels</h3>
            <p class="project-subtitle">Mindfulness, history & subconscious</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 90%"></div>
            </div>
            <span class="progress-text">90% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
        <!-- Project Card 4: Birth Prep Program -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Birth Prep Program</h3>
            <p class="project-subtitle">Holistic care for expectant families</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 50%"></div>
            </div>
            <span class="progress-text">50% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
        <!-- Project Card 5: Family Finance Ed -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Family Finance Ed.</h3>
            <p class="project-subtitle">Playful tools for conscious money</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 75%"></div>
            </div>
            <span class="progress-text">75% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
        <!-- Project Card 6: Parent 360 App -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Parent 360 App</h3>
            <p class="project-subtitle">All-in-one parenting toolkit</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 30%"></div>
            </div>
            <span class="progress-text">30% Dev</span>
          </div>
          <button class="project-btn">View ‚Üí</button>
        </div>
        
      </div>
    </div>
  </div>
</section>


<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script>
gsap.registerPlugin(ScrollTrigger);

// Horizontal scroll per la sezione ABOUT
gsap.to("#about .horizontal-scroll-content", {
  x: () => -(document.querySelector("#about .horizontal-scroll-content").scrollWidth - window.innerWidth),
  ease: "none",
  scrollTrigger: {
    trigger: "#about .horizontal-scroll-wrapper",
    start: "top top",
    end: () => "+=" + (document.querySelector("#about .horizontal-scroll-content").scrollWidth - window.innerWidth),
    scrub: true,
    pin: true,
    anticipatePin: 1
  }
});

// Horizontal scroll per la sezione PROJECTS
gsap.to("#projects .horizontal-scroll-content", {
  x: () => -(document.querySelector("#projects .horizontal-scroll-content").scrollWidth - window.innerWidth),
  ease: "none",
  scrollTrigger: {
    trigger: "#projects .horizontal-scroll-wrapper",
    start: "top top",
    end: () => "+=" + (document.querySelector("#projects .horizontal-scroll-content").scrollWidth - window.innerWidth),
    scrub: true,
    pin: true,
    anticipatePin: 1
  }
});

// Animazioni per le project cards
gsap.fromTo(".project-card", {
  y: 50,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 0.8,
  stagger: 0.2,
  scrollTrigger: {
    trigger: ".projects-grid",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

// Animazione per il titolo della sezione
gsap.fromTo(".section-title", {
  y: 30,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1,
  scrollTrigger: {
    trigger: ".section-header",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

// Animazioni parallax per SUBHERO
gsap.fromTo(".subhero-title", {
  y: 50,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1.2,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

gsap.fromTo(".subhero-subtitle", {
  y: 40,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1,
  delay: 0.3,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 75%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

gsap.fromTo(".subhero-cta", {
  y: 30,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 0.8,
  delay: 0.6,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 70%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});
</script>













<script>
  let scrollScale = 1;
  let bgTransitionProgress = 1;
  let numPoints = 15;
  let lineDistance = 500;
  let points = [];

  const canvas = document.getElementById("iceberg");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function generatePoints() {
    points = [];
    const radius = Math.min(canvas.width, canvas.height) / 4;
    for (let i = 0; i < numPoints; i++) {
      const angle = (Math.PI * 2 * i) / numPoints;
      const x = Math.cos(angle) * radius * (0.5 + Math.random());
      const y = Math.sin(angle) * radius * (0.5 + Math.random());
      points.push({ x, y });
    }
  }

  function initPage() {
    resizeCanvas();
    generatePoints();

    document.getElementById("nodesRange").addEventListener("input", (e) => {
      numPoints = parseInt(e.target.value);
      document.getElementById("nodesValue").textContent = numPoints;
      generatePoints();
    });

    document.getElementById("distanceRange").addEventListener("input", (e) => {
      lineDistance = parseInt(e.target.value);
      document.getElementById("distanceValue").textContent = lineDistance;
    });

    document.getElementById("startBtn").addEventListener("click", () => {
      const preloader = document.getElementById("preloader");
      preloader.classList.add("fade-out");
      setTimeout(() => preloader.remove(), 600);
      document.getElementById("penguin-canvas").style.display = "block";
      requestAnimationFrame(draw);
    });

    // === CONTROLLO CICLO COLORI ===
    const colorToggleBtn = document.getElementById("colorToggle");
    if (colorToggleBtn) {
      // Testi per gli stati del pulsante
      const texts = {
        active: "SYNAPSE",
        hover: "FOCUS", 
        frozen: "LET IT FLOW"
      };
      
      // Gestione tooltip su mobile con touch
      let tooltipTimeout;
      
      // Touch devices: mostra tooltip temporaneamente
      colorToggleBtn.addEventListener("touchstart", (e) => {
        if (window.innerWidth <= 768) {
          e.preventDefault();
          const tooltip = colorToggleBtn.querySelector('.tooltip');
          if (tooltip) {
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
            
            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(() => {
              tooltip.style.opacity = '0';
              tooltip.style.visibility = 'hidden';
            }, 3000);
          }
        }
      });
      
      // Gestione hover desktop - cambia solo il testo, non il tooltip
      colorToggleBtn.addEventListener("mouseenter", () => {
        if (colorCycleActive && window.innerWidth > 768) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.hover}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        }
      });
      
      colorToggleBtn.addEventListener("mouseleave", () => {
        if (colorCycleActive && window.innerWidth > 768) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.active}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        } else if (!colorCycleActive) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.frozen}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        }
      });
      
      // Gestione click
      colorToggleBtn.addEventListener("click", () => {
        colorCycleActive = !colorCycleActive;
        
        if (colorCycleActive) {
          colorToggleBtn.innerHTML = `${texts.active}<div class="tooltip">Controls the iceberg's dynamic color palette.<br><strong>SYNAPSE</strong> ‚Üí <strong>FOCUS</strong> ‚Üí <strong>LET IT FLOW</strong></div>`;
          colorToggleBtn.classList.remove("frozen");
          startColorCycle();
        } else {
          colorToggleBtn.innerHTML = `${texts.frozen}<div class="tooltip">Color cycle paused.<br>Click to resume the flow.</div>`;
          colorToggleBtn.classList.add("frozen");
          stopColorCycle();
        }
      });
    }

    // === CONTROLLO MODALIT√Ä CLARITY ===
    const clarityToggleBtn = document.getElementById("clarityToggle");
    let clarityModeActive = false;
    
    if (clarityToggleBtn) {
      // Gestione tooltip su mobile con touch
      let clarityTooltipTimeout;
      
      // Touch devices: mostra tooltip temporaneamente
      clarityToggleBtn.addEventListener("touchstart", (e) => {
        if (window.innerWidth <= 768) {
          e.preventDefault();
          const tooltip = clarityToggleBtn.querySelector('.tooltip');
          if (tooltip) {
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
            
            clearTimeout(clarityTooltipTimeout);
            clarityTooltipTimeout = setTimeout(() => {
              tooltip.style.opacity = '0';
              tooltip.style.visibility = 'hidden';
            }, 3000);
          }
        }
      });
      
      // Gestione click per attivare/disattivare modalit√† high contrast
      clarityToggleBtn.addEventListener("click", () => {
        clarityModeActive = !clarityModeActive;
        
        if (clarityModeActive) {
          // Attiva modalit√† high contrast
          document.body.classList.add('high-contrast');
          clarityToggleBtn.classList.add('active');
          clarityToggleBtn.innerHTML = `CLARITY<div class="tooltip">High contrast mode active.<br>Click to return to normal view.</div>`;
          
          // Salva preferenza
          localStorage.setItem('clarityMode', 'true');
        } else {
          // Disattiva modalit√† high contrast
          document.body.classList.remove('high-contrast');
          clarityToggleBtn.classList.remove('active');
          clarityToggleBtn.innerHTML = `CLARITY<div class="tooltip">High contrast mode for better readability.<br>Black background with white text.</div>`;
          
          // Rimuovi preferenza
          localStorage.removeItem('clarityMode');
        }
      });
      
      // Carica preferenza salvata
      if (localStorage.getItem('clarityMode') === 'true') {
        clarityToggleBtn.click();
      }
    }

    // === CONTROLLO PANNELLO SYSTEM ===
    const systemToggleBtn = document.getElementById("systemToggle");
    const systemPanel = document.getElementById("systemPanel");
    const closePanelBtn = document.getElementById("closePanelBtn");
    let systemPanelOpen = false;

    if (systemToggleBtn && systemPanel) {
      // Gestione apertura/chiusura pannello
      systemToggleBtn.addEventListener("click", () => {
        systemPanelOpen = !systemPanelOpen;
        
        if (systemPanelOpen) {
          systemPanel.classList.add('open');
          systemToggleBtn.classList.add('active');
        } else {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
        }
      });

      // Bottone chiusura pannello
      if (closePanelBtn) {
        closePanelBtn.addEventListener("click", () => {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
          systemPanelOpen = false;
        });
      }

      // Chiudi pannello premendo ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && systemPanelOpen) {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
          systemPanelOpen = false;
        }
      });

      // === CONTROLLI PANNELLO AVANZATO ===
      
      // Slider FLOW (velocit√† animazioni)
      const flowSlider = document.getElementById("flowSlider");
      const flowValue = document.getElementById("flowValue");
      if (flowSlider && flowValue) {
        flowSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          const speeds = ["Slow", "Normal", "Fast"];
          flowValue.textContent = speeds[value - 1];
          
          // Applica velocit√† alle animazioni
          const speedMultipliers = [0.5, 1, 2];
          document.documentElement.style.setProperty('--animation-speed', speedMultipliers[value - 1]);
        });
      }

      // Slider DEPTH (complessit√† iceberg)
      const depthSlider = document.getElementById("depthSlider");
      const depthValue = document.getElementById("depthValue");
      if (depthSlider && depthValue) {
        depthSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          depthValue.textContent = value;
          numPoints = value;
          generatePoints();
        });
      }

      // Slider NEURAL (background particles)
      const neuralSlider = document.getElementById("neuralSlider");
      const neuralValue = document.getElementById("neuralValue");
      if (neuralSlider && neuralValue) {
        neuralSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          neuralValue.textContent = value ? "On" : "Off";
          
          const particlesCanvas = document.getElementById("particles-background");
          if (particlesCanvas) {
            particlesCanvas.style.display = value ? "block" : "none";
          }
        });
      }

      // Pulsanti del pannello
      const buttons = {
        debug: document.getElementById("debugBtn"),
        grid: document.getElementById("gridBtn"),
        trace: document.getElementById("traceBtn"),
        edit: document.getElementById("editBtn"),
        preview: document.getElementById("previewBtn"),
        publish: document.getElementById("publishBtn"),
        profile: document.getElementById("profileBtn"),
        reset: document.getElementById("resetBtn")
      };

      // Gestione pulsanti toggle
      Object.entries(buttons).forEach(([key, btn]) => {
        if (btn) {
          btn.addEventListener("click", () => {
            btn.classList.toggle('active');
            
            // Logica specifica per ogni pulsante
            switch(key) {
              case 'debug':
                // Mostra/nascondi info debug
                console.log('Debug mode:', btn.classList.contains('active'));
                break;
              case 'grid':
                // Mostra/nascondi griglia
                document.body.classList.toggle('dev-grid', btn.classList.contains('active'));
                break;
              case 'trace':
                // Abilita/disabilita trace mouse
                console.log('Trace mode:', btn.classList.contains('active'));
                break;
              case 'reset':
                // Reset tutte le impostazioni
                if (confirm('Reset all settings to default?')) {
                  location.reload();
                }
                break;
              default:
                console.log(`${key} button clicked`);
            }
          });
        }
      });
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPage);
  } else {
    initPage();
  }
</script>

<script>
function updateSectionsColor(currentBg, currentTextColor, interpolatedColor) {
  // Non aggiornare colori se la modalit√† high contrast √® attiva
  if (document.body.classList.contains('high-contrast')) {
    return;
  }
  
  // Aggiorna sfondi e colori delle sezioni
  document.querySelectorAll('.section, .parallax-section').forEach(section => {
    section.style.background = currentBg;
    section.style.color = currentTextColor;
  });
  
  const subhero = document.querySelector('.subhero');
  if (subhero) {
    subhero.style.background = currentBg;
    subhero.style.color = currentTextColor;
  }

  // Aggiorna colori dinamici per H1, H2, H3 globali
  document.querySelectorAll('h1, h2, h3').forEach(title => {
    title.style.color = currentTextColor;
  });
  
  // Aggiorna colori dinamici per tutte le tagline
  document.querySelectorAll('.tagline').forEach(tagline => {
    tagline.style.color = currentTextColor;
  });
  
  // Aggiorna colori dinamici del pulsante SYNAPSE
  const colorToggleBtn = document.getElementById("colorToggle");
  if (colorToggleBtn && !colorToggleBtn.classList.contains('frozen')) {
    // Usa il colore di sfondo dell'iceberg per il bordo e testo
    const icebergBgColor = interpolatedColor || currentBg;
    colorToggleBtn.style.borderColor = icebergBgColor;
    colorToggleBtn.style.color = icebergBgColor;
    
    // Salva i colori per gli eventi hover
    colorToggleBtn.dataset.icebergBg = icebergBgColor;
    colorToggleBtn.dataset.icebergText = currentTextColor;
  }

  // Aggiorna il bordo dinamico 
  const border = document.querySelector('.dynamic-border');
  if (border) {
    border.style.borderColor = interpolatedColor || currentBg;
  }

  // Aggiorna i colori del breadcrumb
  const breadcrumbDots = document.querySelectorAll('.breadcrumb-dot');
  const breadcrumbProgress = document.getElementById('breadcrumbProgress');
  if (breadcrumbDots.length && breadcrumbProgress) {
    breadcrumbDots.forEach(dot => {
      if (!dot.parentElement.classList.contains('active')) {
        dot.style.background = interpolatedColor || currentBg;
      }
    });
    breadcrumbProgress.style.background = interpolatedColor || currentBg;
  }
}
</script>

<!-- Breadcrumb Navigation Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const breadcrumbItems = document.querySelectorAll('.breadcrumb-item');
  const breadcrumbProgress = document.getElementById('breadcrumbProgress');
  
  const sections = [
    { id: 'hero', element: document.getElementById('hero') || document.querySelector('.hero') },
    { id: 'about', element: document.getElementById('about') },
    { id: 'projects', element: document.getElementById('projects') },
    { id: 'team', element: document.getElementById('team') }
  ].filter(section => section.element);

  console.log('üîç Breadcrumb: Sezioni trovate:', sections.map(s => s.id));
  console.log('üîç Breadcrumb: Numero sezioni:', sections.length);

  // Funzione per aggiornare breadcrumb attivo
  function updateActiveBreadcrumb(activeIndex) {
    breadcrumbItems.forEach((item, index) => {
      item.classList.toggle('active', index === activeIndex);
    });
    
    // Aggiorna progress bar
    const progressPercent = breadcrumbItems.length > 1 ? (activeIndex / (breadcrumbItems.length - 1)) * 100 : 0;
    breadcrumbProgress.style.width = progressPercent + '%';
  }

  // Intersection Observer per rilevare sezione attiva
  const observerOptions = {
    threshold: 0.3,
    rootMargin: '-20% 0px -20% 0px'
  };

  const sectionObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const sectionIndex = sections.findIndex(section => section.element === entry.target);
        console.log('üéØ Sezione vista:', entry.target.id, 'Index:', sectionIndex);
        if (sectionIndex !== -1) {
          updateActiveBreadcrumb(sectionIndex);
        }
      }
    });
  }, observerOptions);

  // Osserva tutte le sezioni
  sections.forEach(section => {
    sectionObserver.observe(section.element);
  });

  // Click handler per navigazione diretta
  breadcrumbItems.forEach((item, index) => {
    item.addEventListener('click', () => {
      console.log('üñ±Ô∏è Breadcrumb click su:', item.querySelector('.breadcrumb-label').textContent, 'Index:', index);
      
      // Attiva sempre l'item cliccato
      updateActiveBreadcrumb(index);
      
      // Trova la sezione corrispondente tramite data-section
      const sectionName = item.getAttribute('data-section');
      const sectionElement = document.getElementById(sectionName) || document.querySelector(`.${sectionName}`);
      
      if (sectionElement) {
        sectionElement.scrollIntoView({ 
          behavior: 'smooth',
          block: 'start'
        });
        console.log('üìç Scroll verso:', sectionName);
      } else {
        console.log('‚ö†Ô∏è Sezione non trovata:', sectionName);
      }
    });
  });

  // Inizializza con la prima sezione attiva
  updateActiveBreadcrumb(0);
});
</script>

<!-- Console Toggle Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const consoleToggle = document.getElementById('consoleToggle');
  const consolePanel = document.getElementById('consolePanel');
  
  if (!consoleToggle || !consolePanel) return;

  // Toggle console panel
  consoleToggle.addEventListener('click', () => {
    const isOpen = consolePanel.classList.toggle('open');
    consoleToggle.classList.toggle('active', isOpen);
  });

  // Chiudi panel cliccando fuori
  document.addEventListener('click', (e) => {
    if (!consoleToggle.contains(e.target) && !consolePanel.contains(e.target)) {
      consolePanel.classList.remove('open');
      consoleToggle.classList.remove('active');
    }
  });

  // Replica la logica dei pulsanti console originali
  const breadcrumbColorToggle = document.getElementById('breadcrumbColorToggle');
  const breadcrumbClarityToggle = document.getElementById('breadcrumbClarityToggle');
  const breadcrumbSystemToggle = document.getElementById('breadcrumbSystemToggle');

  // SYNAPSE button logic
  if (breadcrumbColorToggle) {
    breadcrumbColorToggle.addEventListener('click', () => {
      // Replica la logica del pulsante colorToggle originale
      const originalBtn = document.getElementById('colorToggle');
      if (originalBtn) {
        originalBtn.click();
      }
    });
  }

  // CLARITY button logic  
  if (breadcrumbClarityToggle) {
    breadcrumbClarityToggle.addEventListener('click', () => {
      // Replica la logica del pulsante clarityToggle originale
      const originalBtn = document.getElementById('clarityToggle');
      if (originalBtn) {
        originalBtn.click();
      }
    });
  }

  // SYSTEM button logic
  if (breadcrumbSystemToggle) {
    breadcrumbSystemToggle.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('üîß Breadcrumb SYSTEM clicked');
      
      // Chiudi prima il console panel
      consolePanel.classList.remove('open');
      consoleToggle.classList.remove('active');
      
      // Trova e trigghera il pulsante originale SYSTEM
      const originalSystemBtn = document.getElementById('systemToggle');
      console.log('üîß Original SYSTEM button found:', !!originalSystemBtn);
      
      if (originalSystemBtn) {
        // Simula un click diretto sul pulsante originale
        originalSystemBtn.click();
        console.log('üîß Original SYSTEM button clicked');
      }
    });
  }
});
</script>

<!-- Hero CTA Visibility Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const heroCta = document.getElementById('heroCta');
  if (!heroCta) return;

  let hasScrolled = false;

  function handleScroll() {
    if (!hasScrolled && window.scrollY > 50) {
      hasScrolled = true;
      heroCta.classList.add('visible');
      // Rimuovi il listener dopo il primo scroll
      window.removeEventListener('scroll', handleScroll);
    }
  }

  window.addEventListener('scroll', handleScroll, { passive: true });
});
</script>

<!-- Menu Visibility Control Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Assicurati che GSAP sia caricato
  if (typeof gsap === 'undefined') return;

  const mainMenu = document.querySelector('.main-menu');
  if (!mainMenu) return;

  // Imposta il menu nascosto inizialmente con GSAP
  gsap.set(mainMenu, {
    y: -100,
    opacity: 0,
    visibility: 'hidden'
  });

  // Anima il menu quando si esce dal subhero
  ScrollTrigger.create({
    trigger: "#subhero",
    start: "bottom 80%", // Quando il fondo del subhero raggiunge l'80% della viewport
    end: "bottom top",
    onEnter: () => {
      gsap.to(mainMenu, {
        y: 0,
        opacity: 1,
        visibility: 'visible',
        duration: 0.8,
        ease: "power2.out"
      });
    },
    onLeaveBack: () => {
      gsap.to(mainMenu, {
        y: -100,
        opacity: 0,
        visibility: 'hidden',
        duration: 0.6,
        ease: "power2.in"
      });
    }
  });
});
</script>


<script>
// === Canvas Setup
window.addEventListener("resize", () => {
  resizeCanvas();
  generatePoints();
});

// === Mouse Tracking
let angleOffset = 0, mouseX = 0, mouseY = 0;
document.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = ((e.clientX - rect.left) / canvas.width - 0.5) * 2;
  mouseY = ((e.clientY - rect.top) / canvas.height - 0.5) * 2;
});

// === Dynamic Color Palette
const dynamicPalette = [
  "#00f5d4", "#3a0ca3", "#4361ee", "#4cc9f0", "#5ee4c3",
  "#f72585", "#7209b7", "#2b2d42", "#edf2f4", "#b5179e"
];
let bgColor = dynamicPalette[0], contrastColor = dynamicPalette[1];
let bgColorOld = bgColor, bgColorNew = contrastColor;
let colorCycleActive = true; // Controllo del ciclo colori
let colorChangeInterval; // Riferimento all'intervallo

function lerpColor(a, b, t) {
  const ah = [1, 3, 5].map(i => parseInt(a.slice(i, i + 2), 16));
  const bh = [1, 3, 5].map(i => parseInt(b.slice(i, i + 2), 16));
  const rh = ah.map((v, i) => Math.round(v + (bh[i] - v) * t).toString(16).padStart(2, '0'));
  return `#${rh.join('')}`;
}

function changeColors() {
  if (!colorCycleActive) return;
  
  const bgIndex = Math.floor(Math.random() * dynamicPalette.length);
  let contrastIndex;
  do { contrastIndex = Math.floor(Math.random() * dynamicPalette.length); }
  while (contrastIndex === bgIndex);

  bgColorOld = bgColor;
  bgColorNew = dynamicPalette[bgIndex];
  bgTransitionProgress = 0;
  bgColor = bgColorNew;
  contrastColor = dynamicPalette[contrastIndex];

  const heroText = document.querySelector(".hero-text");
  if (heroText) heroText.style.color = contrastColor;
}

// Avvia il ciclo colori
function startColorCycle() {
  colorChangeInterval = setInterval(changeColors, 2000);
}

// Ferma il ciclo colori
function stopColorCycle() {
  clearInterval(colorChangeInterval);
}

// Inizializza il ciclo
startColorCycle();

// === Iceberg Drawing
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Modalit√† high contrast: sfondo nero, iceberg bianco
  if (document.body.classList.contains('high-contrast')) {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const offsetX = Math.sin(angleOffset) * 20 + mouseX * 30;
    const offsetY = Math.cos(angleOffset) * 20 + mouseY * 30;
    const rotate = Math.sin(angleOffset) * 0.01;
    angleOffset += 0.005;
    
    // Iceberg bianco
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(rotate);
    ctx.scale(scrollScale, scrollScale);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    
    // Riflesso iceberg
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(-rotate);
    ctx.scale(scrollScale, -scrollScale);
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 0.5;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  } else {
    // Modalit√† normale con colori dinamici
    bgTransitionProgress = Math.min(bgTransitionProgress + 0.01, 1);
    const interpolatedColor = lerpColor(bgColorOld, bgColorNew, bgTransitionProgress);
    ctx.fillStyle = interpolatedColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const offsetX = Math.sin(angleOffset) * 20 + mouseX * 30;
    const offsetY = Math.cos(angleOffset) * 20 + mouseY * 30;
    const rotate = Math.sin(angleOffset) * 0.01;
    angleOffset += 0.005;
    
    // Passa sia il background che il colore interpolato per il pulsante
    updateSectionsColor(`linear-gradient(to bottom, ${interpolatedColor}, ${interpolatedColor})`, contrastColor, interpolatedColor);

    // Iceberg top
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(rotate);
    ctx.scale(scrollScale, scrollScale);
    ctx.strokeStyle = contrastColor;
    ctx.lineWidth = 1;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();

    // Iceberg reflection
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(-rotate);
    ctx.scale(scrollScale, -scrollScale);
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = contrastColor;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  requestAnimationFrame(draw);
}
</script>

<script>

// === Inizializzazione sistemi nativi ===
document.addEventListener('DOMContentLoaded', () => {
  initNativeHeroEffects();     // üéØ Hero separato con scroll listener
  initNativeMenuEffects();     // üì± Menu con Intersection Observer  
  initNativeParallaxEffects(); // üåä Sezioni parallax con Intersection Observer
});

// üéØ HERO SYSTEM - Completamente separato dalla logica parallax
function initNativeHeroEffects() {
  console.log('üöÄ Inizializzazione Hero System (separato)');
  
  const heroText = document.querySelector(".hero-text");
  const heroTitles = document.querySelector(".hero-titles-wrapper");
  const hero = document.querySelector(".hero");
  const isMobile = window.innerWidth <= 768;
  
  if (!hero) {
    console.error('‚ùå Elemento .hero non trovato!');
    return;
  }
  
  console.log(isMobile ? 'üì± Hero Mobile mode' : 'üñ•Ô∏è Hero Desktop mode');
  
  let ticking = false;
  
  function handleHeroScroll() {
    if (!ticking) {
      requestAnimationFrame(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const heroHeight = hero.offsetHeight;
        const progress = Math.min(scrollTop / heroHeight, 1);
        
        // üîç Zoom iceberg (opzionale - connesso al canvas)
        if (window.scrollScale !== undefined) {
          window.scrollScale = 1 + progress * (isMobile ? 0.1 : 0.3);
        }
        
        // üìù Animazioni testo hero principale
        if (heroText) {
          heroText.style.opacity = 1 - progress;
          if (!isMobile) {
            heroText.style.transform = `translate(-50%, calc(-50% - ${progress * 80}px))`;
          }
        }
        
        // üéØ Hero Titles - appaiono quando scroll > 66% dell'hero
        if (heroTitles) {
          const threshold = isMobile ? 0.6 : 0.66;
          if (progress > threshold) {
            const titleOpacity = (progress - threshold) / (1 - threshold);
            heroTitles.style.opacity = titleOpacity;
            if (!isMobile) {
              heroTitles.style.transform = `translate(-50%, calc(-50% + ${(1 - progress) * 30}px))`;
            }
            
            // Debug solo al cambiamento
            if (titleOpacity > 0 && titleOpacity < 0.1) {
              console.log('üéØ Hero Titles SHOW - Progress:', Math.round(progress * 100) + '%');
            }
          } else {
            heroTitles.style.opacity = 0;
            if (progress > 0.5 && progress < 0.6) { // Debug una volta
              console.log('üéØ Hero Titles HIDE - Progress:', Math.round(progress * 100) + '%');
            }
          }
        }
        
        ticking = false;
      });
      ticking = true;
    }
  }
  
  // Listener scroll dedicato SOLO per l'hero
  window.addEventListener('scroll', handleHeroScroll, { passive: true });
  
  // Controllo iniziale
  handleHeroScroll();
  
  console.log('‚úÖ Hero System attivo - Scroll listener dedicato');
}


// === ScrollTrigger NATIVO con Intersection Observer ===
function initNativeMenuEffects() {
  console.log('üîß Inizializzazione ScrollTrigger nativo...');
  const menu = document.querySelector(".main-menu");
  const subhero = document.querySelector(".subhero");
  
  if (!menu) {
    console.error('‚ùå Menu .main-menu non trovato!');
    return;
  }
  
  if (!subhero) {
    console.error('‚ùå Sezione .subhero non trovata!');
    return;
  }

  console.log('‚úÖ Menu e Subhero trovati');
  
  // Stato iniziale: nascosto
  menu.style.opacity = '0';
  menu.style.visibility = 'hidden';
  menu.style.transform = 'translateY(-20px)';
  menu.style.transition = 'opacity 0.3s ease-out, visibility 0.3s ease-out, transform 0.3s ease-out';
  
  let menuVisible = false;
  
  function showMenu() {
    if (!menuVisible) {
      console.log('üîº Menu SHOW');
      menuVisible = true;
      menu.style.opacity = '1';
      menu.style.visibility = 'visible';
      menu.style.transform = 'translateY(0)';
    }
  }
  
  function hideMenu() {
    if (menuVisible) {
      console.log('üîΩ Menu HIDE');
      menuVisible = false;
      menu.style.opacity = '0';
      menu.style.visibility = 'hidden';
      menu.style.transform = 'translateY(-20px)';
    }
  }
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      console.log(`üìä Subhero visibility: ${Math.round(entry.intersectionRatio * 100)}%`);

      // Se il subhero √® ancora visibile per pi√π del 33% -> nascondi menu
      if (entry.intersectionRatio > 0.33) {
        hideMenu();
      } 
      // Se il hero √® quasi completamente fuori vista -> mostra menu
      else if (entry.intersectionRatio <= 0.33) {
        showMenu();
      }
    });
  }, {
    // Osserva quando l'hero entra/esce dal viewport
    threshold: [0, 0.1, 0.2, 0.33, 0.5, 0.66, 0.8, 1.0] // Controlli multipli
  });

  // Inizia a osservare il subhero
  observer.observe(subhero);
  console.log('‚úÖ Intersection Observer attivo sul subhero');

  // FALLBACK: Controllo scroll tradizionale come backup
  let ticking = false;
  function handleScrollBackup() {
    if (!ticking) {
      requestAnimationFrame(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const subheroHeight = subhero.offsetHeight;
        const threshold = subheroHeight * 0.66;

        // Log ogni 200px
        if (Math.floor(scrollTop / 200) !== Math.floor((scrollTop - 10) / 200)) {
          console.log(`ÔøΩ BACKUP - Scroll: ${Math.round(scrollTop)}px | Threshold: ${Math.round(threshold)}px`);
        }
        
        ticking = false;
      });
      ticking = true;
    }
  }
  
  window.addEventListener('scroll', handleScrollBackup, { passive: true });
}

// === MENU HAMBURGER CON CSS SEMPLICE ===
document.addEventListener('DOMContentLoaded', function() {
  const hamburgerMenu = document.getElementById('hamburgerMenu');
  const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  
  if (hamburgerMenu && mobileMenuOverlay) {
    // Funzione per chiudere il menu
    function closeMenu() {
      hamburgerMenu.classList.remove('active');
      mobileMenuOverlay.classList.remove('open');
      // Riabilita scroll della pagina
      document.body.style.overflow = '';
    }
    
    // Funzione per aprire il menu
    function openMenu() {
      hamburgerMenu.classList.add('active');
      mobileMenuOverlay.classList.add('open');
      // Blocca scroll della pagina
      document.body.style.overflow = 'hidden';
    }
    
    // Click sul hamburger per aprire/chiudere menu
    hamburgerMenu.addEventListener('click', function() {
      if (mobileMenuOverlay.classList.contains('open')) {
        closeMenu();
      } else {
        openMenu();
      }
    });

    // Click sulla X per chiudere il menu
    if (mobileCloseBtn) {
      mobileCloseBtn.addEventListener('click', closeMenu);
    }

    // Chiudi menu con tasto ESC
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && mobileMenuOverlay.classList.contains('open')) {
        closeMenu();
      }
    });

    // Previeni scroll della pagina quando si scrolla nel menu
    mobileMenuOverlay.addEventListener('wheel', function(e) {
      e.stopPropagation();
    });

    mobileMenuOverlay.addEventListener('touchmove', function(e) {
      e.stopPropagation();
    });

    // Sincronizza i pulsanti mobile con quelli desktop
    const mobileColorToggle = document.getElementById('mobileColorToggle');
    const mobileClarityToggle = document.getElementById('mobileClarityToggle');

    const desktopColorToggle = document.getElementById('colorToggle');
    const desktopClarityToggle = document.getElementById('clarityToggle');

    // Sincronizza CLARITY button
    if (mobileClarityToggle && desktopClarityToggle) {
      mobileClarityToggle.addEventListener('click', () => {
        desktopClarityToggle.click();
        closeMenu();
      });
    }

    // Sincronizza SYNAPSE button
    if (mobileColorToggle && desktopColorToggle) {
      mobileColorToggle.addEventListener('click', () => {
        desktopColorToggle.click();
        closeMenu();
      });
    }

    // Chiudi menu quando si clicca su un link di navigazione
    const mobileNavItems = document.querySelectorAll('.mobile-nav-items .word');
    mobileNavItems.forEach(item => {
      item.addEventListener('click', closeMenu);
    });

    // Gestione CTA JOIN US mobile
    const mobileJoinUsCta = document.getElementById('mobileJoinUsCta');
    if (mobileJoinUsCta) {
      mobileJoinUsCta.addEventListener('click', () => {
        // Qui puoi aggiungere l'azione per JOIN US (es. aprire form, redirect, etc.)
        console.log('JOIN US clicked from mobile');
        closeMenu();
      });
    }
    
    // Gestione CTA SUBHERO
    const subheroJoinBtn = document.querySelector('.subhero-join-btn');
    if (subheroJoinBtn) {
      subheroJoinBtn.addEventListener('click', () => {
        console.log('üöÄ JOIN OUR JOURNEY clicked from SUBHERO');
        
        // Aggiungi effetto visivo
        subheroJoinBtn.style.transform = 'translateY(-3px) scale(0.95)';
        setTimeout(() => {
          subheroJoinBtn.style.transform = '';
        }, 150);
        
        // Qui puoi aggiungere l'azione (es. scroll to contact, open modal, etc.)
        // Per ora mostra un feedback
        showJoinFeedback();
      });
    }
  }
  
  // Funzione feedback per JOIN OUR JOURNEY
  function showJoinFeedback() {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: var(--ice-cyan);
      padding: 1rem 2rem;
      border-radius: 12px;
      border: 2px solid var(--glacier-blue);
      z-index: 1000;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(20px);
      text-align: center;
      transition: all 0.3s ease;
    `;
    notification.textContent = 'üåä Welcome to the journey! Coming soon...';
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.opacity = '1';
      notification.style.transform = 'translateX(-50%) translateY(0)';
    }, 100);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(-50%) translateY(-20px)';
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3000);
  }
});
</script>


<script>
    class NeuralNetwork {
        constructor() {
            this.canvas = document.getElementById('particles-background');
            this.ctx = this.canvas.getContext('2d');
            this.particles = [];
            this.connections = [];
            this.codes = [];
            this.mouse = { x: 0, y: 0 };
            this.animationId = null;

            this.config = {
                particleCount: 80,
                maxDistance: 120,
                particleSize: 3,
                particleSpeed: 0.5,
                connectionOpacity: 0.6,
                pulseSpeed: 0.02,
                codeCount: 15,
                codeSpeed: 0.3,
                colors: {
                    particles: ['#888888', '#999999', '#777777', '#666666', '#aaaaaa','#fff'],
                    connections: '#888888',
                    codes: '#666666'
                }
            };

            this.time = 0;
            this.init();
        }

        init() {
            this.resizeCanvas();
            this.createParticles();
            this.createCodes();
            this.bindEvents();
            this.animate();
        }

        resizeCanvas() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        generateRandomCode() {
            const types = ['binary', 'hex', 'alpha'];
            const type = types[Math.floor(Math.random() * types.length)];

            switch(type) {
                case 'binary':
                    return Array.from({length: 6 + Math.floor(Math.random() * 6)}, () => Math.random() < 0.5 ? '0' : '1').join('');
                case 'hex':
                    const hexChars = '0123456789ABCDEF';
                    return Array.from({length: 4 + Math.floor(Math.random() * 4)}, () => hexChars[Math.floor(Math.random() * hexChars.length)]).join('');
                case 'alpha':
                    const alphaChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                    return Array.from({length: 3 + Math.floor(Math.random() * 4)}, () => alphaChars[Math.floor(Math.random() * alphaChars.length)]).join('');
                default:
                    return '101010';
            }
        }

        createCodes() {
            this.codes = [];
            for (let i = 0; i < this.config.codeCount; i++) {
                this.codes.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * this.config.codeSpeed,
                    vy: (Math.random() - 0.5) * this.config.codeSpeed,
                    text: this.generateRandomCode(),
                    opacity: 0.3 + Math.random() * 0.4,
                    life: 300 + Math.random() * 200,
                    maxLife: 300 + Math.random() * 200,
                    size: 10 + Math.random() * 4
                });
            }
        }

        createParticles() {
            this.particles = [];
            for (let i = 0; i < this.config.particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * this.config.particleSpeed,
                    vy: (Math.random() - 0.5) * this.config.particleSpeed,
                    size: Math.random() * this.config.particleSize + 1,
                    color: this.config.colors.particles[Math.floor(Math.random() * this.config.colors.particles.length)],
                    pulse: Math.random() * Math.PI * 2,
                    activity: Math.random()
                });
            }
        }

        bindEvents() {
            window.addEventListener('resize', () => {
                this.resizeCanvas();
                this.createParticles();
                this.createCodes();
            });

            this.canvas.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            this.canvas.addEventListener('mouseleave', () => {
                this.mouse.x = -1000;
                this.mouse.y = -1000;
            });
        }

        updateParticles() {
            this.particles.forEach(particle => {
                // Movimento base
                particle.x += particle.vx;
                particle.y += particle.vy;

                // Effetto mouse
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    const force = (100 - distance) / 100;
                    particle.vx += dx * force * 0.001;
                    particle.vy += dy * force * 0.001;
                    particle.activity = Math.min(1, particle.activity + 0.02);
                } else {
                    particle.activity = Math.max(0, particle.activity - 0.005);
                }

                // Limitazione velocit√†
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 2) {
                    particle.vx = (particle.vx / speed) * 2;
                    particle.vy = (particle.vy / speed) * 2;
                }

                // Bordi del canvas
                if (particle.x < 0 || particle.x > this.canvas.width) {
                    particle.vx *= -1;
                    particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
                }
                if (particle.y < 0 || particle.y > this.canvas.height) {
                    particle.vy *= -1;
                    particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
                }

                // Aggiornamento pulsazione
                particle.pulse += this.config.pulseSpeed;
            });
        }

        updateCodes() {
            this.codes.forEach((code, index) => {
                // Movimento
                code.x += code.vx;
                code.y += code.vy;

                // Vita del codice
                code.life--;
                code.opacity = (code.life / code.maxLife) * 0.7;

                // Bordi del canvas
                if (code.x < -50 || code.x > this.canvas.width + 50) {
                    code.vx *= -1;
                }
                if (code.y < -20 || code.y > this.canvas.height + 20) {
                    code.vy *= -1;
                }

                // Rigenera codice se morto
                if (code.life <= 0) {
                    code.x = Math.random() * this.canvas.width;
                    code.y = Math.random() * this.canvas.height;
                    code.text = this.generateRandomCode();
                    code.life = code.maxLife;
                    code.opacity = 0.3 + Math.random() * 0.4;
                }

                // Cambia codice occasionalmente
                if (Math.random() < 0.001) {
                    code.text = this.generateRandomCode();
                }
            });
        }

        drawConnections() {
            this.ctx.strokeStyle = this.config.colors.connections;
            this.ctx.lineWidth = 1;

            for (let i = 0; i < this.particles.length; i++) {
                for (let j = i + 1; j < this.particles.length; j++) {
                    const p1 = this.particles[i];
                    const p2 = this.particles[j];

                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.config.maxDistance) {
                        const opacity = (1 - distance / this.config.maxDistance) * this.config.connectionOpacity;
                        const activity = (p1.activity + p2.activity) / 2;

                        // Effetto pulsazione nelle connessioni
                        const pulse = Math.sin(this.time * 0.01 + distance * 0.01) * 0.3 + 0.7;

                        this.ctx.globalAlpha = opacity * pulse * (0.3 + activity * 0.7);
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();

                        // Segnali neurali che viaggiano lungo le connessioni
                        if (Math.random() < 0.001 + activity * 0.01) {
                          this.drawNeuralSignal(p1, p2, distance);
                        }
                    }
                }
            }
        }

        drawNeuralSignal(p1, p2, distance) {
            const progress = (this.time * 0.02) % 1;
            const x = p1.x + (p2.x - p1.x) * progress;
            const y = p1.y + (p2.y - p1.y) * progress;

            this.ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.8;
            this.ctx.fillStyle = '#cccccc';
            this.ctx.beginPath();
            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }

        drawParticles() {
            this.particles.forEach(particle => {
                const pulseScale = 1 + Math.sin(particle.pulse) * 0.3 * particle.activity;
                const size = particle.size * pulseScale;

                // Glow effect grigio
                this.ctx.shadowColor = particle.color;
                this.ctx.shadowBlur = 10 + particle.activity * 15;

                // Corpo principale
                this.ctx.globalAlpha = 0.7 + particle.activity * 0.3;
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Nucleo leggermente pi√π chiaro
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = '#bbbbbb';
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size * 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;
            });
        }

        drawCodes() {
            this.ctx.font = '12px "Courier New", monospace';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            this.codes.forEach(code => {
                this.ctx.globalAlpha = code.opacity;
                this.ctx.fillStyle = this.config.colors.codes;

                // Effetto leggero glow per i codici
                this.ctx.shadowColor = this.config.colors.codes;
                this.ctx.shadowBlur = 5;

                this.ctx.fillText(code.text, code.x, code.y);

                this.ctx.shadowBlur = 0;
            });
        }

        animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.updateParticles();
            this.updateCodes();
            this.drawConnections();
            this.drawParticles();
            this.drawCodes();

            this.time++;
            this.animationId = requestAnimationFrame(() => this.animate());
        }

        destroy() {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
            }
            window.removeEventListener('resize', this.resizeCanvas);
            this.canvas.removeEventListener('mousemove', this.mouseMoveHandler);
            this.canvas.removeEventListener('mouseleave', this.mouseLeaveHandler);
        }
    }

    // Inizializzazione
    const neuralNetwork = new NeuralNetwork();

    // Cleanup quando la pagina viene chiusa
    window.addEventListener('beforeunload', () => {
        neuralNetwork.destroy();
    });
</script>

<script>
// ‚ö° SEZIONI PARALLAX SYSTEM - Separato dall'Hero
function initNativeParallaxEffects() {
  console.log('üåä Inizializzazione Parallax System (solo sezioni, NO hero)');
  document.body.style.overflowY = 'auto';
  initParallaxImages();
  initParallaxText();
  initParallaxMovement();
  initParallaxBackgrounds();
}

// üñºÔ∏è Parallax IMMAGINI
function initParallaxImages() {
  const parallaxImages = document.querySelectorAll('.parallax-image:not(.hero .parallax-image), .parallax-section .parallax-image, section:not(.hero) .parallax-image');
  console.log(`üñºÔ∏è Parallax: Trovate ${parallaxImages.length} immagini (hero escluso)`);

  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      const progress = entry.intersectionRatio;

      if (entry.isIntersecting) {
        entry.target.classList.add('parallax-active');

        const isMobile = window.innerWidth <= 768;
        const scaleRange = isMobile ? 0.1 : 0.3;
        const yRange = isMobile ? 60 : 100;

        const scale = (isMobile ? 0.6 : 0.5) + (scaleRange * progress);
        const y = (isMobile ? 30 : 50) - (yRange * progress);
        const opacity = 0.2 + (0.8 * progress);

        entry.target.style.transform = `scale(${scale}) translateY(${y}px)`;
        entry.target.style.opacity = opacity;
        entry.target.style.transition = 'transform 0.6s ease-out, opacity 0.6s ease-out';

        if (progress === 1) console.log(`üñºÔ∏è Immagine parallax completamente visibile`);
      }
    });
  }, {
    threshold: Array.from({ length: 6 }, (_, i) => i / 5),
    rootMargin: '50px 0px -50px 0px'
  });

  parallaxImages.forEach(image => imageObserver.observe(image));
}

// üìù Parallax TESTO migliorato
function initParallaxText() {
  const parallaxTexts = document.querySelectorAll(
    '.parallax-text:not(.hero .parallax-text), .parallax-section .parallax-text, section:not(.hero) .parallax-text'
  );
  console.log(`üìù Parallax: Trovati ${parallaxTexts.length} testi (hero escluso)`);

  const textObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      if (entry.isIntersecting && entry.intersectionRatio > 0.15) {
        entry.target.style.opacity = '1';
        entry.target.style.transform = 'translateY(0)';
        textObserver.unobserve(entry.target); // ‚¨ÖÔ∏è migliora performance
        console.log('üìù Testo parallax attivato');
      }
    });
  }, {
    threshold: 0.15,
    rootMargin: '0px 0px -20% 0px'
  });

  parallaxTexts.forEach(text => {
    // Imposta solo se non gi√† presenti
    if (!text.style.opacity) text.style.opacity = '0';
    if (!text.style.transform) text.style.transform = 'translateY(40px)';
    if (!text.style.transition) text.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';
    textObserver.observe(text);
  });
}


// üé≠ Parallax MOVIMENTO
const activeParallaxImgs = new Set();

function handleGlobalParallaxScroll() {
  activeParallaxImgs.forEach(img => {
    const rect = img.getBoundingClientRect();
    const scrollProgress = (window.innerHeight - rect.top) / (window.innerHeight + rect.height);
    const clampedProgress = Math.max(0, Math.min(1, scrollProgress));
    const yOffset = 100 - (200 * clampedProgress);
    img.style.transform = `translateY(${yOffset}px)`;
  });
}
window.addEventListener('scroll', handleGlobalParallaxScroll, { passive: true });

function initParallaxMovement() {
  const parallaxImgs = document.querySelectorAll('.parallax-img:not(.hero .parallax-img), .parallax-section .parallax-img, section:not(.hero) .parallax-img');
  console.log(`üé≠ Parallax: Trovate ${parallaxImgs.length} immagini con movimento (hero escluso)`);

  parallaxImgs.forEach(img => {
    const movementObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.target.closest('.hero')) return;

        if (entry.isIntersecting) {
          activeParallaxImgs.add(entry.target);
          handleGlobalParallaxScroll(); // aggiorna subito
          console.log('üé≠ Movimento parallax attivato');
        } else {
          activeParallaxImgs.delete(entry.target);
        }
      });
    }, { threshold: 0.1 });

    movementObserver.observe(img);
  });
}

// üåà Parallax SFONDI
function initParallaxBackgrounds() {
  const bgLayers = document.querySelectorAll('.bg-layer:not(.hero .bg-layer), .parallax-section .bg-layer,.bg-layer');
  console.log(`üåà Parallax: Trovati ${bgLayers.length} sfondi (hero escluso)`);

  const bgObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      if (entry.isIntersecting) {
        const progress = entry.intersectionRatio;
        entry.target.style.backgroundPosition = `0% ${progress * 100}%`;
        entry.target.style.transition = 'background-position 0.6s ease-out';

        if (progress === 1) {
          console.log(`üåà Sfondo parallax completamente attivo`);
        }
      }
    });
  }, {
    threshold: Array.from({ length: 6 }, (_, i) => i / 5)
  });

  bgLayers.forEach(bg => bgObserver.observe(bg));
}
</script>















<!-- ‚úÖ QUESTI SONO GLI UNICI SCRIPT CHE SERVONO -->
<script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>

<!-- ‚úÖ TUTTO RACCHIUSO IN UNA FUNZIONE PER EVITARE CONFLITTI CON L'ICEBERG -->
<script>
  document.addEventListener("DOMContentLoaded", () => {
    initPenguinCanvas();
  });

  function rgbToHex(rgb) {
    const result = rgb.match(/\d+/g).map(Number).slice(0, 3);
    return (
      '#' +
      result.map(x => x.toString(16).padStart(2, '0')).join('')
    );
  }

  function enableCanvasDrag(canvas, controlsPenguin) {
    let isDragging = false;
    let offsetX, offsetY;

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      canvas.classList.add("dragging");
      controlsPenguin.enabled = false; // üî¥ Disabilita Orbit durante il drag

      const rect = canvas.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;

      canvas.style.position = 'fixed';
      canvas.style.left = `${e.clientX - offsetX}px`;
      canvas.style.top = `${e.clientY - offsetY}px`;
      canvas.style.right = 'auto';
      canvas.style.bottom = 'auto';
    });

    document.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.classList.remove("dragging");
      controlsPenguin.enabled = true; // ‚úÖ Riattiva Orbit alla fine del drag
    });
  }

  function initPenguinCanvas() {
    const canvas = document.getElementById("penguin-canvas");
    if (!canvas) {
      console.error("Canvas con id 'penguin-canvas' non trovato!");
      return;
    }

    const dpr = window.devicePixelRatio || 1;
    canvas.width = 1000 * dpr;
    canvas.height = 1000 * dpr;

    const scenePenguin = new THREE.Scene();
    scenePenguin.background = null;

    const aspect = canvas.width / canvas.height;
    const cameraPenguin = new THREE.PerspectiveCamera(60, aspect, 1, 100000);
    cameraPenguin.position.set(500, -300, 1500);
    cameraPenguin.lookAt(500, -300, 0);

    const rendererPenguin = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true
    });
    rendererPenguin.setClearColor(0x000000, 0);
    rendererPenguin.setSize(600, 500, false);
    rendererPenguin.setPixelRatio(dpr);

    const controlsPenguin = new THREE.OrbitControls(cameraPenguin, rendererPenguin.domElement);
    controlsPenguin.enableZoom = false;
    controlsPenguin.enablePan = true;
    controlsPenguin.minDistance = 800;
    controlsPenguin.maxDistance = 6000;
    controlsPenguin.maxPolarAngle = Math.PI;
    controlsPenguin.minPolarAngle = 0;
    controlsPenguin.target.set(500, -300, -250);
    controlsPenguin.update();

    enableCanvasDrag(canvas, controlsPenguin);

    canvas.addEventListener("mouseenter", () => {
      if (!controlsPenguin.enabled) controlsPenguin.enabled = true;
    });
    canvas.addEventListener("mouseleave", () => {
      if (!canvas.classList.contains("dragging")) {
        controlsPenguin.enabled = false;
      }
    });

    let dynamicMaterial = null;

    fetch('prova.json')
      .then(res => res.json())
      .then(data => {
        const points = data.penguinpoints;
        const edges = data.penguinedges;

        const vertices = [];
        edges.forEach(([start, end]) => {
          const p1 = points[start];
          const p2 = points[end];
          vertices.push(new THREE.Vector3(p1.x, -p1.y, 0));
          vertices.push(new THREE.Vector3(p2.x, -p2.y, 0));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(vertices);
        dynamicMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const lines = new THREE.LineSegments(geometry, dynamicMaterial);
        scenePenguin.add(lines);
      })
      .catch(err => console.error('Errore caricamento JSON:', err));

    function updateMaterialColorFromHero() {
      const heroText = document.querySelector('.hero-text');
      if (!heroText || !dynamicMaterial) return;

      const color = getComputedStyle(heroText).color;
      const hex = rgbToHex(color);
      if (dynamicMaterial.color.getStyle() !== hex) {
        dynamicMaterial.color.set(hex);
      }
    }

    function animatePenguin() {
      requestAnimationFrame(animatePenguin);
      updateMaterialColorFromHero();
      rendererPenguin.render(scenePenguin, cameraPenguin);
    }

    animatePenguin();
  }
</script>

<!-- ‚úÖ EFFETTO FADE-IN DELLE IMMAGINI PARALLAX CON SCROLL -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Seleziona tutte le immagini parallax nei layout flex
  const parallaxImages = document.querySelectorAll('.flex-2col .parallax-image, .flex-full .parallax-image, .parallax-image, .parallax-image');
  
  // Crea l'Intersection Observer
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // Aggiunge la classe in-view quando l'immagine entra in vista
        entry.target.classList.add('in-view');
      }
    });
  }, {
    threshold: 0.3, // Trigger quando il 30% dell'immagine √® visibile
    rootMargin: '0px 0px -50px 0px' // Trigger un po' prima che sia completamente visibile
  });
  
  // Osserva tutte le immagini parallax
  parallaxImages.forEach(image => {
    imageObserver.observe(image);
  });
});
</script>

<!-- ‚úÖ EFFETTO COMPOSIZIONE TESTO LETTERA PER LETTERA CON CLASSE CSS -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  
  // Funzione per applicare l'effetto composizione testo
  function applyTextCompositionEffect(element) {
    // Salva il contenuto HTML originale per preservare <br> e altri tag
    const originalHTML = element.innerHTML;
    const originalStyle = window.getComputedStyle(element);
    
    // Evita overflow sui contenitori
    const parent = element.parentElement;
    if (parent) {
      parent.style.overflow = 'hidden';
    }
    
    // Funzione per processare nodi di testo preservando la struttura
    function processTextNode(textNode) {
      const text = textNode.textContent;
      const letters = [];
      
      // Crea span per ogni lettera
      text.split('').forEach((char, index) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char; // Preserva spazi
        span.style.display = 'inline-block';
        span.style.position = 'relative';
        span.style.opacity = '0';
        span.style.transform = 'translateX(20px) scale(0.8)'; // üî• Ridotto da 50px a 20px
        span.style.transition = `all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
        span.dataset.letterIndex = letters.length; // Indice globale
        letters.push(span);
      });
      
      // Sostituisce il nodo di testo con gli span
      const fragment = document.createDocumentFragment();
      letters.forEach(letter => fragment.appendChild(letter));
      textNode.parentNode.replaceChild(fragment, textNode);
      
      return letters;
    }
    
    // Trova tutti i nodi di testo nell'elemento
    function getTextNodes(node) {
      const textNodes = [];
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        textNodes.push(node);
      } else {
        for (let child of node.childNodes) {
          textNodes.push(...getTextNodes(child));
        }
      }
      return textNodes;
    }
    
    // Processa tutti i nodi di testo
    const textNodes = getTextNodes(element);
    const allLetters = [];
    
    textNodes.forEach(textNode => {
      const letters = processTextNode(textNode);
      allLetters.push(...letters);
    });
    
    // Aggiorna gli indici per l'animazione sequenziale
    allLetters.forEach((letter, globalIndex) => {
      letter.style.transitionDelay = `${globalIndex * 0.03}s`;
      letter.dataset.globalIndex = globalIndex;
    });
    
    // Marca come processato
    element.dataset.textComposition = 'processed';
    
    // Intersection Observer per attivare l'animazione
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Ritardo di attivazione per rendere l'effetto pi√π elegante
          setTimeout(() => {
            // Attiva l'animazione delle lettere
            allLetters.forEach((letter, index) => {
              setTimeout(() => {
                letter.style.opacity = '1';
                letter.style.transform = 'translateX(0) scale(1)';
              }, index * 30); // 30ms tra ogni lettera
            });
          }, 300); // Ritardo iniziale di 300ms
          
          // Smette di osservare una volta attivato
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.1, // Attiva quando anche solo il 10% dell'elemento √® visibile
      rootMargin: '0px 0px 0px 0px' // Nessun margine - attiva appena √® in vista
    });
    
    observer.observe(element);
    
    // CONTROLLO IMMEDIATO: Se l'elemento √® gi√† visibile al caricamento, attiva subito
    setTimeout(() => {
      const rect = element.getBoundingClientRect();
      const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
      
      if (isVisible && allLetters.length > 0 && allLetters[0].style.opacity === '0') {
        // Ritardo di attivazione anche per elementi gi√† visibili
        setTimeout(() => {
          // Attiva l'animazione immediatamente
          allLetters.forEach((letter, index) => {
            setTimeout(() => {
              letter.style.opacity = '1';
              letter.style.transform = 'translateX(0) scale(1)';
            }, index * 30);
          });
        }, 500); // Ritardo maggiore per elementi gi√† visibili (hero section)
        observer.unobserve(element);
      }
    }, 200); // Piccolo delay per assicurarsi che il DOM sia pronto
  }
  
  // AUTO-RILEVAMENTO: Cerca automaticamente tutti gli elementi con la classe 'text-compose'
  // ESCLUSI: elementi che hanno 'no-text-compose' o 'mobile-no-text-compose' su mobile
  function initTextComposition() {
    const isMobile = window.innerWidth <= 768;
    let selector = '.text-compose:not(.no-text-compose):not([data-text-composition="processed"])';
    
    // Su mobile, escludi anche gli elementi con 'mobile-no-text-compose'
    if (isMobile) {
      selector = '.text-compose:not(.no-text-compose):not(.mobile-no-text-compose):not([data-text-composition="processed"])';
    }
    
    const textComposeElements = document.querySelectorAll(selector);
    
    textComposeElements.forEach(element => {
      applyTextCompositionEffect(element);
    });
  }
  
  // Avvia il rilevamento automatico
  setTimeout(initTextComposition, 100);
  
  // Espone la funzione globalmente per il riuso
  window.initTextComposition = initTextComposition;
  
  // Funzione globale per applicare manualmente l'effetto (opzionale)
  window.activateTextComposition = function(selectors) {
    if (typeof selectors === 'string') {
      selectors = [selectors];
    }
    
    selectors.forEach(selector => {
      const targetElements = document.querySelectorAll(`${selector}:not([data-text-composition="processed"])`);
      targetElements.forEach(element => {
        applyTextCompositionEffect(element);
      });
    });
  };
});
</script>

<!-- ‚úÖ ACCORDION RIUTILIZZABILE -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Gestione click Read More riutilizzabile
  const readMoreBtn = document.getElementById('readMoreBtn');
  const readMoreContent = document.getElementById('readMoreContent');
  const readMoreText = readMoreBtn?.querySelector('.read-more-text');
  const readLessText = readMoreBtn?.querySelector('.read-less-text');
  
  if (readMoreBtn && readMoreContent) {
    readMoreBtn.addEventListener('click', () => {
      const isOpen = readMoreContent.classList.contains('open');
      
      if (isOpen) {
        // Chiudi: contenuto completo -> solo preview
        readMoreContent.classList.remove('open');
        readMoreText.style.display = 'inline';
        readLessText.style.display = 'none';
      } else {
        // Apri: mostra contenuto completo
        readMoreContent.classList.add('open');
        readMoreText.style.display = 'none';
        readLessText.style.display = 'inline';
        
        // Attiva text-compose sul nuovo contenuto
        setTimeout(() => {
          if (window.initTextComposition) {
            window.initTextComposition();
          }
        }, 400); // Delay per sincronizzarsi con l'animazione
      }
    });
  }
});
</script>

<!-- Project Cards Interaction -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Project cards click handlers
  const projectCards = document.querySelectorAll('.project-card');
  const projectBtns = document.querySelectorAll('.project-btn');
  
  // Add click handlers to project cards
  projectCards.forEach((card, index) => {
    card.addEventListener('click', (e) => {
      // Prevent button click from triggering card click
      if (e.target.classList.contains('project-btn')) {
        return;
      }
      
      const projectTitle = card.querySelector('.project-title').textContent;
      console.log(`üöÄ Opening project: ${projectTitle}`);
      
      // Add visual feedback
      card.style.transform = 'scale(0.98)';
      setTimeout(() => {
        card.style.transform = '';
      }, 150);
      
      // Here you could navigate to project page or open modal
      // For now, just log the action
      showProjectInfo(projectTitle);
    });
  });
  
  // Add click handlers to project buttons
  projectBtns.forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent card click
      
      const card = btn.closest('.project-card');
      const projectTitle = card.querySelector('.project-title').textContent;
      
      console.log(`üìã View details for: ${projectTitle}`);
      
      // Add button animation
      btn.style.transform = 'translateX(10px) scale(1.05)';
      setTimeout(() => {
        btn.style.transform = '';
      }, 200);
      
      showProjectDetails(projectTitle);
    });
  });
  
  // Project info function
  function showProjectInfo(projectName) {
    // Create a simple notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 100px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: var(--ice-cyan);
      padding: 1rem 1.5rem;
      border-radius: 8px;
      border: 2px solid var(--glacier-blue);
      z-index: 1000;
      font-size: 0.9rem;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(20px);
      transition: all 0.3s ease;
    `;
    notification.textContent = `Project: ${projectName} - Coming Soon!`;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.transform = 'translateY(0)';
      notification.style.opacity = '1';
    }, 100);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.transform = 'translateY(-20px)';
      notification.style.opacity = '0';
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3000);
  }
  
  // Project details function
  function showProjectDetails(projectName) {
    showProjectInfo(`${projectName} Details`);
  }
  
  // Add hover effects for project cards
  projectCards.forEach((card) => {
    const progressBar = card.querySelector('.progress-fill');
    const originalWidth = progressBar.style.width;
    
    card.addEventListener('mouseenter', () => {
      // Animate progress bar on hover
      progressBar.style.transition = 'width 0.5s ease';
      const currentWidth = parseInt(originalWidth);
      progressBar.style.width = Math.min(currentWidth + 10, 100) + '%';
    });
    
    card.addEventListener('mouseleave', () => {
      // Reset progress bar
      progressBar.style.width = originalWidth;
    });
  });
});
</script>

</body>
</html>
