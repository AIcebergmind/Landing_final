<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aiceberg Mind - Hero</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
<canvas id="particles-background"></canvas>

  <style>
    :root {
      --glacier-blue: #5EE4C3;
      --ice-cyan: #3AC8F5;
      --twilight: #a6c1ee;
      --deep-night: #0F2B3A;
      --frost-white: #F5F9FF;
    }

    body, html {
      margin: 0;
      padding: 0;
    font-family: "IBM Plex Sans", sans-serif;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
    }

    body {
  scroll-snap-type: y mandatory;
}
.horizontal-scroll-wrapper {
  scroll-snap-align: start;
  scroll-snap-stop: always;
}

  .ibm-plex-sans {
    font-family: "IBM Plex Sans", sans-serif;
    font-weight: 400;
    font-style: normal;
  }



/* === STILI GLOBALI TITOLI === */
h1 {
  font-size: clamp(2.8rem, 4vw, 2.8rem);
  font-weight: 700;
  line-height: 1.2;
  margin: 2rem 0;
  padding: 2rem 0;
  position: relative;
}

/* Linea wireframe sopra H1 */
h1::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

/* Linea wireframe sotto H1 */
h1::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

h2 {
  font-size: clamp(1.4rem, 3vw, 2.2rem);
  font-weight: 500;
  line-height: 1.3;
  margin: 0 0 1.5rem 0;
  text-transform: uppercase;
}

h3 {
  font-size: clamp(1.4rem, 3vw, 2.2rem);
  font-weight: 400;
  line-height: 1.4;
  margin: 0 0 1rem 0;
}

/* === STILE GLOBALE TAGLINE === */
.tagline {
  font-size: clamp(1.2rem, 3vw, 2rem);
  font-weight: 300;
  font-style: italic;
  line-height: 1.4;
  margin: 0 0 2rem 0;
  /* Il colore verrà impostato dinamicamente dall'iceberg */
}

/* === STILI GLOBALI PARAGRAFI === */
p {
  font-size: 1rem;
  line-height: 1.7;
  margin: 0 0 1.5rem 0;
  color: #333;
}

/* Paragrafi su sfondi scuri */
.dark-bg p, 
section[style*="background: #"] p {
  color: #fff;
}


/* Paragrafi su sfondi chiari */
.light-bg p, 
section[style*="background: #"] p {
  color: #000000;
}



/* === FUNYIONI E MODULI GLOBALI ================ */

/* === ACCORDION RIUTILIZZABILE === */
.accordion {
  margin: 2rem 0;
  max-width: 800px;
}

.accordion-header {
  cursor: pointer;
  padding: 1rem 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
}

.accordion-header:hover {
  opacity: 0.8;
}

.accordion-content {
  overflow: hidden;
  transition: max-height 0.5s ease-out;
  max-height: 0;
}

.accordion.open .accordion-content {
  max-height: 800px; /* Regola in base al contenuto */
}

.accordion-text {
  padding: 1.5rem 0;
  line-height: 1.6;
}

/* === SEZIONI DINAMICHE PER ACCORDION === */
.parallax-section:has(.accordion.open) {
  height: auto !important;
  min-height: auto !important;
}

/* Assicura che tutti i contenitori si adattino al contenuto */
.section1, .section2, .section3, .section4 {
  height: auto !important;
  min-height: 100vh;
  margin: 0 !important; /* Nessun margin tra sezioni */
  padding: 0 !important; /* Nessun padding nelle sezioni stesse */
}


.read-more-container {
  max-width: 800px;
  margin: 2rem 0;
}

.read-more-preview {
  line-height: 1.6;
  margin-bottom: 1.5rem;
}

.read-more-content {
  overflow: hidden;
  transition: max-height 0.8s ease-out, opacity 0.6s ease-out;
  max-height: 0;
  opacity: 0;
}

.read-more-content.open {
  max-height: 1000px; /* Altezza sufficiente per tutto il contenuto */
  opacity: 1;
}

.read-more-text {
  line-height: 1.6;
  padding-top: 0.5rem;
}

.read-more-btn {
  background: transparent;
  border: 1px solid currentColor;
  color: inherit;
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-family: inherit;
}

.read-more-btn:hover {
  background: currentColor;
  color: #fff;
  transform: translateY(-2px);
}

/* === REGOLE RESPONSIVE SEMPLICI === */

/* DESKTOP: Solo breadcrumb, no menu */
@media (min-width: 769px) {
  .main-menu {
    display: none !important;
  }
  
  .breadcrumb-container {
    display: flex !important;
  }
}

/* MOBILE: Solo menu, no breadcrumb */
@media (max-width: 768px) {
  .breadcrumb-container {
    display: none !important;
  }
  
  .main-menu {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
  }
}

/* Responsive read more */
@media (max-width: 768px) {
  .read-more-container {
    margin: 1.5rem 0;
  }
  
  .read-more-btn {
    width: 100%;
    padding: 1rem;
  }
}

/* === DIVIDERS RIUTILIZZABILI === */
/* Divider semplice con linea */
.divider {
  margin: 3rem 0;
  text-align: center;
  position: relative;
}

.divider::before {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 20%, 
    currentColor 80%, 
    transparent 100%);
  opacity: 0.3;
}

/* Divider con simbolo al centro */
.divider-symbol {
  margin: 3rem 0;
  text-align: center;
  position: relative;
  font-size: 1.5rem;
  color: currentColor;
  opacity: 0.6;
}

.divider-symbol::before,
.divider-symbol::after {
  content: '';
  position: absolute;
  top: 50%;
  width: 30%;
  height: 1px;
  background: linear-gradient(90deg, transparent, currentColor, transparent);
  opacity: 0.3;
}

.divider-symbol::before {
  left: 0;
}

.divider-symbol::after {
  right: 0;
}

/* Divider wireframe (stile iceberg) */
.divider-wireframe {
  margin: 3rem 0;
  height: 40px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.divider-wireframe::before {
  content: '';
  position: absolute;
  width: 60px;
  height: 30px;
  border: 1px solid currentColor;
  border-radius: 50% 50% 0 0;
  opacity: 0.3;
  animation: float 3s ease-in-out infinite;
}

.divider-wireframe::after {
  content: '';
  position: absolute;
  top: 20px;
  width: 80px;
  height: 1px;
  background: linear-gradient(90deg, 
    transparent 0%, 
    currentColor 30%, 
    currentColor 70%, 
    transparent 100%);
  opacity: 0.2;
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-3px); }
}

/* Divider dots */
.divider-dots {
  margin: 3rem 0;
  text-align: center;
}

.divider-dots::before {
  content: '• • •';
  font-size: 1.2rem;
  letter-spacing: 0.8rem;
  color: currentColor;
  opacity: 0.4;
}

/* Divider spacing variants */
.divider-sm { margin: 1.5rem 0; }
.divider-lg { margin: 4rem 0; }
.divider-xl { margin: 5rem 0; }

/* Responsive dividers */
@media (max-width: 768px) {
  .divider,
  .divider-symbol,
  .divider-wireframe,
  .divider-dots {
    margin: 2rem 0;
  }
  
  .divider-lg { margin: 2.5rem 0; }
  .divider-xl { margin: 3rem 0; }
}

/* === TOOLTIP RESPONSIVO === */
.tooltip {
  position: absolute;
  top: 120%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  color: #fff;
  padding: 0.8rem 1.2rem;
  border-radius: 0.8rem;
  font-size: 0.85rem;
  font-weight: 400;
  line-height: 1.4;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  z-index: 1000;
  pointer-events: none;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.tooltip::before {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-bottom-color: rgba(0, 0, 0, 0.9);
}

.color-toggle-btn:hover .tooltip {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(5px);
}

/* Responsive tooltip per mobile */
@media (max-width: 768px) {
  .tooltip {
    position: fixed;
    top: auto;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    white-space: normal;
    max-width: calc(100vw - 2rem);
    text-align: center;
    font-size: 0.8rem;
    padding: 0.6rem 1rem;
  }
  
  .tooltip::before {
    display: none;
  }
  
  .color-toggle-btn:hover .tooltip {
    transform: translateX(-50%) translateY(0);
  }
}






/* ========== MENU E PULSANTI ========== */

.main-menu {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: white;
  padding: 1rem 2rem;
  z-index: 100;
  transform: translateY(-100%);
  transition: transform 0.6s ease, opacity 0.3s ease, visibility 0.3s ease;
}

.main-menu.visible {
  transform: translateY(0);
}

.main-menu.visible-menu {
  visibility: visible !important;
  opacity: 1 !important;
  transform: translateY(0) !important;
}

#wordCanvas {
  width: 100%;
  height: 100%;
  display: block;
}

.wordcanvas {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5rem;
  justify-content: center;
  align-items: center;
  padding: 1rem 2rem;
  background: transparent;
}

.word {
  font-size: clamp(1rem, 2vw, 3rem);
  cursor: pointer;
  color: var(--ice-cyan);
  transition: transform 0.3s ease;
  user-select: none;
}

.word:hover {
  transform: scale(1.2);
  color: var(--glacier-blue);
}


 @media (max-width: 768px) {
  /* === NASCONDI BREADCRUMB SU MOBILE === */
  .breadcrumb-container {
    display: none !important;
  }
  
  /* === MENU HAMBURGER RESPONSIVE === */
  .hamburger-menu {
    display: flex !important;
    background: rgba(255, 0, 0, 0.2); /* DEBUG: sfondo rosso per vedere se c'è */
    border: 2px solid var(--glacier-blue);
  }
  
  .wordcanvas {
    justify-content: space-between;
    padding: 0.5rem 1rem;
  }
  
  .wordcanvas > .word {
    display: none; /* Nascondi le parole del menu normale */
  }
  
  .console-container {
    display: none; /* Nascondi la console nel menu principale */
  }
  
  .main-menu {
    height: 70px; /* Riduci altezza menu su mobile */
  }
  
  /* === DISABILITA PINGUINO SU MOBILE === */
  #penguin-canvas {
    display: none !important;
  }
  
  .console-container {
    margin-left: 0;
    margin-top: 1rem;
    padding: 1rem 1.5rem 0.8rem 1.5rem;
    border-radius: 6px;
  }
  
  .console-buttons {
    flex-direction: column;
    gap: 0.8rem;
  }
  
  .color-toggle-btn {
    margin: 0;
    width: 100%;
    text-align: center;
  }
  
  /* === DISABILITA SYSTEM PANEL SU MOBILE === */
  .system-panel {
    display: none !important;
  }
}






/* === PULSANTi === */
.color-toggle-btn {
  background: transparent;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.5rem 1rem;
  border-radius: 2rem;
  font-size: clamp(0.9rem, 1.5vw, 1.2rem);
  font-family: inherit;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  margin: 0 0.5rem;
  position: relative;
  /* I colori verranno aggiornati dinamicamente dall'iceberg */
}

.color-toggle-btn:hover {
  /* Lo sfondo hover verrà impostato dinamicamente */
  color: #fff;
  transform: scale(1.05);
}

.color-toggle-btn.frozen {
  background: #ff6b6b;
  border-color: #ff6b6b;
  color: #fff;
}

.color-toggle-btn.frozen:hover {
  background: #ff5252;
  border-color: #ff5252;
}

/* === CONSOLE CONTAINER === */
.console-container {
  position: relative;
  padding: 1.5rem 2rem 1.2rem 2rem;
  margin-left: 2rem;
  border: 2px solid var(--ice-cyan);
  border-radius: 8px;
  transition: all 0.3s ease;
}

.console-container:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.console-label {
  position: absolute;
  top: -12px;
  left: 20px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.15em;
  color: var(--ice-cyan);
  background: white;
  padding: 0 0.8rem;
  text-transform: uppercase;
}

.console-buttons {
  display: flex;
  gap: 1rem;
  align-items: center;
}

/* === CTA JOIN US === */
.join-us-cta {
  background: linear-gradient(135deg, var(--ice-cyan), #5dade2);
  border: none;
  color: white;
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  margin-left: 1.5rem;
  transition: all 0.3s ease;
  text-transform: uppercase;
  box-shadow: 0 4px 15px rgba(0, 174, 239, 0.3);
}

.join-us-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 174, 239, 0.4);
  background: linear-gradient(135deg, #5dade2, var(--ice-cyan));
}

/* CTA nascosta su mobile */
@media (max-width: 768px) {
  .join-us-cta {
    display: none;
  }
}

/* === SYSTEM PANEL === */
.system-panel {
  position: fixed;
  top: 0;
  right: -400px;
  width: 380px;
  height: 100vh;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-left: 2px solid var(--ice-cyan);
  transition: right 0.4s ease;
  z-index: 500;
  overflow-y: auto;
}

.system-panel.open {
  right: 0;
}

.system-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1.5rem;
  border-bottom: 1px solid var(--ice-cyan);
  background: rgba(255, 255, 255, 0.8);
}

.system-panel-title {
  font-weight: 600;
  font-size: 1.1rem;
  color: var(--ice-cyan);
  letter-spacing: 0.1em;
}

.close-panel-btn {
  background: none;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.close-panel-btn:hover {
  background: var(--ice-cyan);
  color: white;
}

.system-panel-content {
  padding: 1.5rem;
}

.control-section {
  margin-bottom: 2rem;
}

.control-section h4 {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--deep-night);
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  border-bottom: 1px solid #eee;
  padding-bottom: 0.5rem;
}

.control-group {
  display: flex;
  flex-wrap: wrap;
  gap: 0.8rem;
  margin-bottom: 1rem;
}

.system-btn {
  background: transparent;
  border: 1px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  font-size: 0.8rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.system-btn:hover, .system-btn.active {
  background: var(--ice-cyan);
  color: white;
}

.slider-control {
  width: 100%;
  margin-bottom: 1rem;
}

.slider-control label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  font-weight: 500;
  color: var(--deep-night);
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.slider-control input[type="range"] {
  width: 100%;
  accent-color: var(--ice-cyan);
  height: 4px;
}

.slider-control span {
  color: var(--ice-cyan);
  font-weight: 600;
}

/* === PULSANTE CLARITY === */
#clarityToggle {
  background: transparent;
  border: 2px solid #666;
  color: #666;
}

#clarityToggle:hover {
  background: #666;
  color: #fff;
  transform: scale(1.05);
}

#clarityToggle.active {
  background: #000;
  border-color: #000;
  color: #fff;
}

#clarityToggle.active:hover {
  background: #222;
  border-color: #222;
}

/* === MODALITÀ HIGH CONTRAST === */
body.high-contrast {
  background: #000 !important;
  color: #fff !important;
}

body.high-contrast .main-menu {
  background: #000 !important;
  color: #fff !important;
  border-bottom: 1px solid #333;
}

body.high-contrast .console-container {
  border-color: #fff !important;
}

body.high-contrast .console-label {
  color: #fff !important;
  background: #000 !important;
}

body.high-contrast .system-panel {
  background: rgba(0, 0, 0, 0.95) !important;
  border-left-color: #fff !important;
}

body.high-contrast .system-panel-header {
  background: rgba(0, 0, 0, 0.9) !important;
  border-bottom-color: #fff !important;
}

body.high-contrast .system-panel-title {
  color: #fff !important;
}

body.high-contrast .close-panel-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .close-panel-btn:hover {
  background: #fff !important;
  color: #000 !important;
}

body.high-contrast .control-section h4 {
  color: #fff !important;
  border-bottom-color: #333 !important;
}

body.high-contrast .system-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .system-btn:hover,
body.high-contrast .system-btn.active {
  background: #fff !important;
  color: #000 !important;
}

body.high-contrast .slider-control label {
  color: #fff !important;
}

body.high-contrast .slider-control span {
  color: #fff !important;
}

body.high-contrast section,
body.high-contrast .parallax-section {
  background: #000 !important;
  color: #fff !important;
}

body.high-contrast h1,
body.high-contrast h2,
body.high-contrast h3,
body.high-contrast p,
body.high-contrast .tagline,
body.high-contrast .intro-text {
  color: #fff !important;
}

body.high-contrast .word {
  color: #fff !important;
}

body.high-contrast .word:hover {
  color: #ccc !important;
}

body.high-contrast #iceberg {
  background: #000 !important;
}

body.high-contrast .hero-text {
  color: #fff !important;
}

/* === HIGH CONTRAST per MENU MOBILE === */
body.high-contrast .hamburger-line {
  background: #fff !important;
}

body.high-contrast .mobile-menu-overlay {
  background: rgba(0, 0, 0, 0.95) !important;
  border-left: 1px solid #fff;
}

body.high-contrast .mobile-nav-items .word {
  color: #fff !important;
  border-bottom-color: rgba(255, 255, 255, 0.2);
}

body.high-contrast .mobile-console-container {
  border-top-color: rgba(255, 255, 255, 0.2);
}

body.high-contrast .mobile-console-container .console-label {
  color: #fff !important;
}

body.high-contrast .mobile-console-container .color-toggle-btn {
  border-color: #fff !important;
  color: #fff !important;
}

body.high-contrast .mobile-console-container .color-toggle-btn:hover {
  background: #fff !important;
  color: #000 !important;
}

/* === MENU HAMBURGER === */
.hamburger-menu {
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  width: 30px;
  height: 30px;
  cursor: pointer;
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 400;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border-radius: 50%;
  padding: 8px;
  border: 2px solid var(--ice-cyan);
  transition: all 0.3s ease;
}

.hamburger-menu:hover {
  background: var(--ice-cyan);
}

.hamburger-menu:hover .hamburger-line {
  background: #000;
}

/* Mostra hamburger solo su mobile quando breadcrumb è nascosto */
@media (max-width: 768px) {
  .hamburger-menu {
    display: flex;
  }
}

.hamburger-line {
  width: 25px;
  height: 3px;
  background: var(--ice-cyan);
  margin: 3px 0;
  transition: all 0.3s ease;
  transform-origin: center;
}

.hamburger-menu.active .hamburger-line:nth-child(1) {
  transform: rotate(45deg) translate(6px, 6px);
}

.hamburger-menu.active .hamburger-line:nth-child(2) {
  opacity: 0;
}

.hamburger-menu.active .hamburger-line:nth-child(3) {
  transform: rotate(-45deg) translate(6px, -6px);
}

.mobile-menu-overlay {
  position: fixed;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100vh;
  background: rgba(176, 224, 230, 0.95); /* Glacier blue */
  backdrop-filter: blur(20px);
  z-index: 300;
  display: flex;
  flex-direction: column;
  padding-top: 80px;
  /* CSS transition per slide effect */
  transition: left 0.4s ease-in-out;
  /* Scroll abilitato */
  overflow-y: auto;
  overflow-x: hidden;
}

/* Scrollbar personalizzata per mobile menu */
.mobile-menu-overlay::-webkit-scrollbar {
  width: 4px;
}

.mobile-menu-overlay::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin: 80px 0 20px 0; /* Evita sovrapposizione con X e bordo inferiore */
}

.mobile-menu-overlay::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.4);
  border-radius: 2px;
  transition: background 0.3s ease;
}

.mobile-menu-overlay::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.6);
}

/* Per Firefox */
.mobile-menu-overlay {
  scrollbar-width: thin;
  scrollbar-color: rgba(255, 255, 255, 0.4) rgba(255, 255, 255, 0.1);
}

/* Scrollbar in modalità clarity */
body.high-contrast .mobile-menu-overlay::-webkit-scrollbar-thumb {
  background: rgba(0, 0, 0, 0.4);
}

body.high-contrast .mobile-menu-overlay::-webkit-scrollbar-thumb:hover {
  background: rgba(0, 0, 0, 0.6);
}

body.high-contrast .mobile-menu-overlay {
  scrollbar-color: rgba(0, 0, 0, 0.4) rgba(255, 255, 255, 0.1);
}

.mobile-menu-overlay.open {
  left: 0;
}

/* X per chiudere il menu */
.mobile-close-btn {
  position: absolute;
  top: 20px;
  right: 20px;
  font-size: 1.8rem;
  font-weight: bold;
  color: white;
  cursor: pointer;
  z-index: 400;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: transparent;
  border: 2px solid rgba(176, 224, 230, 1); /* Bordo glacier blue */
  transition: all 0.3s ease;
}

.mobile-close-btn:hover {
  background: rgba(176, 224, 230, 0.2);
  transform: scale(1.1);
}

/* Modalità clarity - X nera */
body.high-contrast .mobile-close-btn {
  color: #000;
  border-color: rgba(176, 224, 230, 1);
}

body.high-contrast .mobile-close-btn:hover {
  background: rgba(176, 224, 230, 0.3);
}

.mobile-nav-items {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
  padding: 1.5rem 2rem;
  align-items: flex-end;
}

.mobile-nav-items .word {
  font-size: 1.2rem;
  text-align: right;
  padding: 0.6rem 0.8rem;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  width: auto;
}

.mobile-console-container {
  margin-top: 1.5rem;
  padding: 1.5rem 2rem;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  position: relative;
}

/* Fix per la label CONSOLE su mobile - posizionata dentro il container */
.mobile-console-container .console-label {
  position: relative !important;
  top: auto !important;
  left: auto !important;
  margin-bottom: 1rem;
  background: none !important;
  padding: 0 !important;
  font-size: 0.85rem;
  text-align: center;
}

.mobile-console-container .console-buttons {
  flex-direction: column;
  gap: 0.8rem;
}

.mobile-console-container .color-toggle-btn {
  width: 100%;
  padding: 0.8rem;
  font-size: 0.95rem;
}

/* === CTA JOIN US MOBILE === */
.mobile-cta-container {
  margin-top: 2rem;
  padding: 0 2rem 2rem 2rem; /* Aggiunto padding bottom per scroll */
  display: flex;
  justify-content: center;
}

.mobile-join-us-cta {
  background: linear-gradient(135deg, var(--ice-cyan), #5dade2);
  border: none;
  color: white;
  padding: 1rem 2rem;
  border-radius: 30px;
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  box-shadow: 0 4px 15px rgba(0, 174, 239, 0.4);
  width: 100%;
  max-width: 200px;
}

.mobile-join-us-cta:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 174, 239, 0.5);
  background: linear-gradient(135deg, #5dade2, var(--ice-cyan));
}


/* === LAYOUT SEZIONI === */

/* Classe generale per sezioni */

    section {
      position: relative;
      min-height: 100vh; /* Cambiato da height a min-height per flessibilità */
      height: auto; /* Permette l'espansione in base al contenuto */
      display: flex;
      align-items: flex-start;
      justify-content: center;
      text-align: left;
      z-index: 6;
      padding: 2rem;
      width: 100%;
      box-sizing: border-box;
      flex-direction: column;
    }



/* === LAYOUT FLEXBOX  === */

/* Contenitore a 2 colonne */
.flex-2col {
  display: flex;
  gap: 3rem;
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  align-items: center;
  height: auto; /* Altezza automatica basata sul contenuto */
  min-height: auto; /* Nessuna altezza minima */
}

.flex-2col > * {
  flex: 1; /* Ogni figlio prende la stessa larghezza */
}

/* Contenitore a larghezza piena */
.flex-full {
  max-width: 1200px;
  margin: 2rem auto;
  padding: 0 2rem;
  width: 100%;
  height: auto; /* Altezza automatica basata sul contenuto */
  min-height: auto; /* Nessuna altezza minima */
}

/* Responsive per mobile */
@media (max-width: 768px) {
  .flex-2col {
    flex-direction: column;
    gap: 2rem;
  }
}





   .parallax-section {
      text-align: left;
      display: block;
      padding: 1.5rem 2rem; /* Ridotto da 3rem a 1.5rem */
      margin-top: 0; /* Rimuove margin tra sezioni */
      z-index: 5;
      min-height: auto; /* Override min-height per sezioni parallax */
      height: auto; /* Altezza completamente flessibile */
      flex-direction: column; /* Per contenuti che si sviluppano verticalmente */
      overflow-x: hidden; /* 🔥 Evita scroll orizzontale nelle sezioni */
    }





    /* Responsive padding per sezioni */
    @media (max-width: 768px) {
      .parallax-section {
        padding: 1rem 1rem; /* Ridotto da 1.5rem a 1rem per ancora meno spazio */
        margin-top: 0; /* Nessun margin tra sezioni anche su mobile */
      }
    
    }

    .parallax-image {
      position: absolute;
      width: 60vw;
      max-width: 800px;
      z-index: 2;
      opacity: 0.2;
    }





.horizontal-scroll-wrapper {
  position: relative;
  height: 60vh; /* Ridotto da 100vh a 60vh per essere coerente con content */
    padding: 0 !important;
  margin: 0 !important;
  overflow: hidden;
}
.horizontal-scroll-content {
  position: relative;
  top: 0;
  left: 0;
  display: flex;
  width: max-content;
  height: 60vh; /* Ridotto da 100vh a 60vh */
  will-change: transform;
}

.card-scroll {
  min-width: 50vw; /* Ridotto da 60vw a 50vw */
  flex: 0 0 auto;
  margin-right: 1rem; /* Ridotto da 2rem a 1rem */
  display: flex;
  align-items: stretch;
}
.flex-2col-scroll {
  display: flex;
  flex-direction: row;
  gap: 1.5rem; /* Ridotto da 2rem a 1.5rem */
  width: 80%;
}
.card-title {
  flex: 0 0 180px; /* Ridotto da 220px a 180px */
  font-size: 1.6rem; /* Ridotto da 2rem a 1.6rem */
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: flex-start;
}
.card-content {
  flex: 1 1 auto;
  display: flex;
  align-items: center;
}

/* === SECTION HEADERS (GENERALE) === */
.section-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 0 2rem;
}

.section-title {
  font-size: 3.5rem;
  font-weight: 700;
  color: var(--ice-cyan);
  margin-bottom: 0.5rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.section-subtitle {
  font-size: 1.3rem;
  color: var(--glacier-blue);
  font-weight: 400;
  opacity: 0.9;
}

/* === PROJECTS SECTION === */
#projects {
  position: relative;
  min-height: 80vh; /* Ridotto da 100vh */
  padding: 0; /* Rimosso padding - usa quello di parallax-section */
  color: white;
}

#projects .parallax-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -1;
  overflow: hidden;
}

#projects .parallax-bg img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  opacity: 0.3;
}

.projects-content {
  position: relative;
  z-index: 2;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.projects-wrapper {
  flex: 1;
  min-height: 400px;
}

.projects-grid {
  display: flex;
  gap: 2rem;
  padding: 0 2rem;
  align-items: center;
}

.project-card {
  min-width: 350px;
  width: 350px;
  height: 300px;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 16px;
  padding: 2rem;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.project-card:hover {
  transform: translateY(-10px) scale(1.02);
  border-color: var(--ice-cyan);
  box-shadow: 0 20px 60px rgba(94, 228, 195, 0.2);
}

.project-card:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(94, 228, 195, 0.1), transparent);
  transition: left 0.6s ease;
}

.project-card:hover:before {
  left: 100%;
}

.project-header {
  margin-bottom: 2rem;
}

.project-title {
  font-size: 1.4rem;
  font-weight: 700;
  color: white;
  margin-bottom: 0.5rem;
  line-height: 1.3;
}

.project-subtitle {
  font-size: 0.95rem;
  color: var(--glacier-blue);
  font-weight: 400;
  opacity: 0.8;
  line-height: 1.4;
}

.project-progress {
  margin-bottom: 1.5rem;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 3px;
  overflow: hidden;
  margin-bottom: 0.5rem;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--ice-cyan), var(--glacier-blue));
  border-radius: 3px;
  transition: width 0.8s ease;
  position: relative;
}

.progress-fill:after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: progressShine 2s infinite;
}

@keyframes progressShine {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.progress-text {
  font-size: 0.8rem;
  color: var(--ice-cyan);
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
}

.project-btn {
  background: transparent;
  border: 2px solid var(--glacier-blue);
  color: var(--glacier-blue);
  padding: 0.8rem 1.5rem;
  border-radius: 25px;
  font-size: 0.9rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  align-self: flex-start;
}

.project-btn:hover {
  background: var(--glacier-blue);
  color: #000;
  transform: translateX(5px);
}

/* Responsive Projects */
@media (max-width: 768px) {
  #projects {
    padding: 0; /* Nessun padding aggiuntivo - usa solo parallax-section */
    min-height: 60vh; /* Ridotto anche per mobile */
  }
  
  /* Section Headers Responsive (generale) */
  .section-title {
    font-size: 2.2rem; /* Ridotto da 3.5rem */
  }
  
  .section-subtitle {
    font-size: 1rem; /* Ridotto da 1.3rem */
  }
  
  .section-header {
    margin-bottom: 1rem; /* Ridotto spacing su mobile */
    padding: 0 1rem; /* Ridotto padding laterale */
  }
  
  .projects-wrapper {
    height: auto;
    overflow-x: auto;
    overflow-y: hidden;
  }
  
  .projects-grid {
    flex-direction: row;
    flex-wrap: nowrap;
    padding: 0 1rem;
  }
  
  .project-card {
    min-width: 280px;
    width: 280px;
    height: 250px;
    padding: 1.5rem;
  }
  
  .project-title {
    font-size: 1.2rem;
  }
  
  .project-subtitle {
    font-size: 0.85rem;
  }
}




    /* Override per immagini parallax nel flex */

    .flex-2col .parallax-image,
    .flex-full .parallax-image {
      position: relative;
      width: 100%;
      max-width: 100%;
      height: auto;
      opacity: 0.2;
      transform: translateY(20px) scale(0.5); /* Parte da metà scala */
      transition: opacity 1.5s ease-out, transform 1.5s ease-out;
      transform-origin: center center; /* Zoom dal centro */
    }

    /* Stato visibile quando in vista */
    .flex-2col .parallax-image.in-view,
    .flex-full .parallax-image.in-view {
      opacity: 1;
      transform: translateY(0) scale(0.8); /* Si sviluppa all'80% */
    }

    .parallax-text {
      z-index: 2;
      font-size: 2rem;
      max-width: 60vw;
    }

/* === RIDUZIONE SPAZIO TRA SEZIONI === */
#about {
  padding-bottom: 0.5rem; /* Riduce padding-bottom specifico per ABOUT */
  padding-top:100px; /* Compensazione per breadcrumb fisso (60px + margine) */
}

#projects {
  padding-top: 0.5rem; /* Riduce padding-top specifico per PROJECTS */
}

/* Mobile: ancora meno spazio */
@media (max-width: 768px) {
  #about {
    padding-bottom: 0.25rem;
  }
  
  #projects {
    padding-top: 0.25rem;
  }
}

/* === RESPONSIVE PARALLAX IMAGES === */
@media (max-width: 768px) {
  /* Su mobile: immagini parallax centrate e non sovrapposte */
  .flex-2col .parallax-image,
  .flex-full .parallax-image {
    display: block;
    margin: 2rem auto; /* Centrate con margin */
    max-width: calc(100% - 4rem); /* Rispetta il padding del sito */
    width: auto;
    height: auto;
    position: relative;
    transform: translateY(20px) scale(0.6); /* Più piccole su mobile */
  }
  
  .flex-2col .parallax-image.in-view,
  .flex-full .parallax-image.in-view {
    transform: translateY(0) scale(0.7); /* Scale finale più contenuta su mobile */
  }
  
  /* Contenitori flex-2col su mobile diventano colonna */
  .flex-2col {
    flex-direction: column;
    gap: 3rem; /* Più spazio tra contenuto e immagine */
  }
  
  /* Ordine degli elementi su mobile */
  .flex-2col .parallax-image {
    order: 2; /* Immagine dopo il contenuto */
  }
  
  .flex-2col .content-column {
    order: 1; /* Contenuto prima */
  }
}



  /* PRELOADER*/

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #333;
  border-top-color: #fff;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.logo {
  transition: opacity 0.3s ease, transform 0.3s ease;
  opacity: 1;
}


#preloader {
  position: fixed;
  inset: 0;
  background: linear-gradient(to bottom, #fff 0%, #000 100%);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  transition: opacity 0.6s ease;
}

#preloader.fade-out {
  opacity: 0;
  pointer-events: none;
}

.preloader-controls {
  margin-top: 2rem;
  padding: 2rem 2.5rem;
  box-shadow: 0 4px 32px rgba(255, 255, 255, 0.1);
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  align-items: center;
}

.preloader-controls label {
  color: #ffffff;
  font-size: 1.1rem;
  font-weight: 500;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.3rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.preloader-controls input[type="range"] {
  width: 200px;
  accent-color: var(--glacier-blue);
  margin-top: 0.5rem;
  height: 4px;
}

.preloader-controls span {
  margin-left: 0.5rem;
  font-weight: bold;
  color: #ffffff;
  font-size: 1.1rem;
}

#startBtn {
  margin-top: 1rem;
  padding: 0.7rem 2.2rem;
  background: transparent;
  color: #ffffff;
  border: 2px solid #000;
  border-radius: 4px;
  font-size: 1.1rem;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

#startBtn:hover {
  background: #000;
  color: #fff;
}

@media (max-width: 600px) {
  .preloader-controls {
    padding: 1.2rem 1rem;
    width: 90vw;
  }
  .preloader-controls input[type="range"] {
    width: 120px;
  }
}


#preloader .preloader-logo {
  width: 160px;
  max-width: 30vw;
  margin-bottom: 2rem;
  opacity: 1;
  transform: scale(1);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

#preloader .preloader-logo img {
  width: 100%;
  height: auto;
  display: block;
}










/* ICEBERG E PINGUINO */

#iceberg {
  width: 100%;
  height: 100%;
  display: block;
  transform-origin: center center;
  background-color: #2b2d42; /* fallback se il canvas non disegna subito */
}

#penguin-canvas {
  width: 400px;     
  height: auto;
  position: fixed;
  bottom: 40px;
  right: 40px;
  z-index: 300;
   cursor: grab;
}

#penguin-canvas.dragging {
  cursor: grabbing;
}




/* GLOBAL EFFECT */

    #particles-background {
        position: fixed;
        top: 0;
        left: 0;
  width: 100vw;
  height: 100vh;
        z-index: 15;
      pointer-events: none;      
  background: transparent;
    }











/* HERO E SUBHERO */





.hero {
  position: relative;
  width: 100vw;
  height: 100vh;
  z-index:10;
  padding: 0;
  margin: 0;
          display: flex; /* da qui propeita section */
      align-items: flex-start;
      justify-content: center;
      text-align: left;
      z-index: 6;
      width: 100%;
      box-sizing: border-box;
      flex-direction: column;

}
.hero-text {
  position: absolute;
  z-index: 10;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 4rem;
  font-weight: normal;
  color: white;
  line-height: 2;
  transition: opacity 1s ease, transform 1s ease, color 0.8s ease;
}

.hero-text-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  pointer-events: none;
}


.hero-titles-wrapper {
  position: absolute;
  bottom: -120px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 5;
  text-align: center;
  opacity: 0;
  pointer-events: none;
}


.horizon-line {
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 4.5px;
  background: linear-gradient(to right, rgba(255,255,255,0.2), rgba(90,220,255,0.5), rgba(255,255,255,0.2));
  z-index: 1;
  pointer-events: none;
}

.scroll-indicator {
  position: absolute;
  top: 50%;
  right: 100px;
  transform: translateY(-50%);
  height: 250px;
  width: 4px;
  background-color: #222; /* linea verticale */
  z-index: 20;
  opacity: 0.6;
}

.scroll-text {
  position: absolute;
  right: 15px;
  top: 50%;
  transform-origin: right center;
  font-size: 20px;
  letter-spacing: 0.1em;
  color: #222;
  opacity: 0.8;
  pointer-events: none;
  user-select: none;
}

.scroll-box {
  position: absolute;
  top: 0;
  left: -6px;
  width: 14px;
  height: 14px;
  background-color: #5EE4C3; /* rettangolino animato */
  border-radius: 3px;
  animation: scrollDown 2.5s infinite ease-in-out;
}

@keyframes scrollDown {
  0%   { top: 0; opacity: 1; }
  50%  { top: 250px; opacity: 0.4; }
  100% { top: 0; opacity: 1; }
}

/* === HERO CTA === */
.hero-cta {
  position: absolute;
  bottom: 60px;
  right: 60px;
  z-index: 25;
  opacity: 0;
  visibility: hidden;
  transform: translateY(20px);
  transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  display: none; /* Nascosta ora che usiamo quella nella SUBHERO */
}

.hero-cta.visible {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.hero-join-btn {
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(20px);
  border: 2px solid var(--ice-cyan, #5EE4C3);
  color: var(--ice-cyan, #5EE4C3);
  padding: 1rem 2rem;
  border-radius: 50px;
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 8px 32px rgba(94, 228, 195, 0.2);
  position: relative;
  overflow: hidden;
}

.hero-join-btn:hover {
  background: var(--ice-cyan, #5EE4C3);
  color: #000;
  transform: translateY(-2px);
  box-shadow: 0 12px 40px rgba(94, 228, 195, 0.4);
}

.hero-join-btn:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: left 0.5s;
}

.hero-join-btn:hover:before {
  left: 100%;
}

/* Responsive Hero CTA */
@media (max-width: 768px) {
  .hero-cta {
    bottom: 40px;
    right: 20px;
    left: 20px;
    text-align: center;
  }
  
  .hero-join-btn {
    width: 100%;
    max-width: 200px;
    padding: 0.8rem 1.5rem;
    font-size: 0.9rem;
  }
}





/* === SUBHERO -=== */
.subhero {
  /* background now handled by body for global effect */
  color: #fff;
  padding: 1.5rem 1.5rem 2.5rem 1.5rem; /* Aggiunto padding-bottom maggiore */
  margin: 0;
  width: 100%;
  min-height: 80vh; /* Aumentato per consistenza con altre sezioni */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  position: relative;
  z-index: 1;
  opacity: 1;
  font-size: 1.2rem;
  text-align: center;
  border: none;
  box-shadow: 0 8px 32px rgba(58,200,245,0.08);
}

.subhero-container {
  color: #fff;
}

.subhero-title {
  color: var(--ice-cyan);
  transition: color 0.5s;
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
}

.subhero-subtitle {
  color: var(--glacier-blue);
  transition: color 0.5s;
  font-size: 1.2rem;
  font-weight: 400;
  margin-bottom: 0;
}

/* === SUBHERO CTA === */
.subhero-cta {
  margin-top: 2.5rem;
  text-align: center;
  position: relative;
}

.cta-divider {
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--ice-cyan), transparent);
  margin: 0 auto 1.5rem auto;
  border-radius: 1px;
}

.subhero-cta-text {
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.1rem;
  font-weight: 500;
  margin-bottom: 2rem;
  line-height: 1.5;
  letter-spacing: 0.05em;
  font-style: italic;
}

.subhero-join-btn {
  background: linear-gradient(135deg, rgba(94, 228, 195, 0.1), rgba(94, 228, 195, 0.05));
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 1.2rem 3rem;
  border-radius: 50px;
  font-size: 1.1rem;
  font-weight: 700;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  box-shadow: 
    0 4px 20px rgba(94, 228, 195, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.1);
  position: relative;
  overflow: hidden;
  display: inline-flex;
  align-items: center;
  gap: 0.8rem;
}

/* Desktop: wider border */
@media (min-width: 768px) {
  .subhero-join-btn {
    border-width: 3px;
  }
}

.btn-icon {
  font-size: 1.2rem;
  opacity: 0.8;
  transition: all 0.3s ease;
}

.btn-arrow {
  font-size: 1rem;
  opacity: 0.7;
  transition: all 0.3s ease;
  transform: translateX(0);
}

.subhero-join-btn:hover {
  background: linear-gradient(135deg, var(--ice-cyan), rgba(94, 228, 195, 0.9));
  color: #000;
  transform: translateY(-4px) scale(1.02);
  box-shadow: 
    0 12px 35px rgba(94, 228, 195, 0.4),
    0 0 30px rgba(94, 228, 195, 0.3),
    inset 0 1px 0 rgba(255, 255, 255, 0.2);
}

.subhero-join-btn:hover .btn-icon {
  opacity: 1;
  transform: scale(1.1);
}

.subhero-join-btn:hover .btn-arrow {
  opacity: 1;
  transform: translateX(3px);
}

.subhero-join-btn:before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  transition: left 0.6s;
}

.subhero-join-btn:hover:before {
  left: 100%;
}

/* Effetto pulsante */
.subhero-join-btn:after {
  content: '';
  position: absolute;
  top: -2px;
  left: -2px;
  right: -2px;
  bottom: -2px;
  border-radius: 50px;
  background: linear-gradient(45deg, var(--ice-cyan), var(--glacier-blue), var(--ice-cyan));
  z-index: -1;
  opacity: 0;
  transition: opacity 0.3s ease;
  animation: borderPulse 2s infinite;
}

.subhero-join-btn:hover:after {
  opacity: 0.6;
}

@keyframes borderPulse {
  0%, 100% { transform: scale(1); opacity: 0.3; }
  50% { transform: scale(1.05); opacity: 0.1; }
}

  .dynamic-border {
    display: inline-block;
    padding: 1.5em 3.8rem;
    border: 3px solid var(--ice-cyan, #5EE4C3);
    border-radius: 2.5em;
    transition: border-color 0.6s cubic-bezier(.4,0,.2,1);
    box-sizing: border-box;
  }

/* === BREADCRUMB PROGRESS BAR === */
.breadcrumb-container {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 60px;
  background: rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(20px);
  z-index: 400;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 2rem;
  box-sizing: border-box;
  transition: all 0.3s ease;
}

.breadcrumb-progress {
  position: absolute;
  top: 0;
  left: 0;
  height: 3px;
  background: var(--ice-cyan);
  width: 0%;
  transition: width 0.3s ease;
}

.breadcrumb-sections {
  display: flex;
  gap: 3rem;
  align-items: center;
}

.breadcrumb-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 0.6;
  position: relative;
}

.breadcrumb-item.active {
  opacity: 1;
}

.breadcrumb-dot {
  display: none; /* Nasconde i pallini */
}

.breadcrumb-label {
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  color: white;
  text-transform: uppercase;
  transition: all 0.3s ease;
  position: relative;
}

.breadcrumb-item.active .breadcrumb-label {
  font-weight: 700;
  font-size: 0.8rem;
  color: var(--glacier-blue);
  transform: translateY(-2px);
}

.breadcrumb-item .breadcrumb-label:after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 2px;
  background: var(--glacier-blue);
  transition: width 0.3s ease;
}

.breadcrumb-item.active .breadcrumb-label:after {
  width: 100%;
}

.breadcrumb-item:hover {
  opacity: 1;
  transform: translateY(-2px);
}

.breadcrumb-item:hover .breadcrumb-label:after {
  width: 60%;
}

/* Responsive breadcrumb */
@media (max-width: 768px) {
  .breadcrumb-container {
    height: 50px;
    padding: 0 1rem;
    /* Nasconde breadcrumb su mobile */
    display: none;
  }
  
  .breadcrumb-sections {
    gap: 1.5rem;
  }
  
  .breadcrumb-label {
    font-size: 0.6rem;
  }
  
  .breadcrumb-item.active .breadcrumb-label {
    font-size: 0.7rem;
  }
}

/* === CONSOLE TOGGLE IN BREADCRUMB === */
.breadcrumb-console-toggle {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  opacity: 1;
  margin-left: auto;
  padding-left: 2rem;
  border-left: 2px solid var(--glacier-blue);
  position: relative;
}

.breadcrumb-console-toggle:hover {
  transform: translateY(-2px);
}

.console-label {
  font-size: 0.7rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  color: var(--glacier-blue);
  text-transform: uppercase;
  line-height: 1;
  margin: 0;
  padding: 0;
  display: inline-block;
  vertical-align: middle;
}

.console-arrow {
  font-size: 0.6rem;
  color: var(--glacier-blue);
  transition: transform 0.3s ease;
  font-weight: bold;
  line-height: 1;
  margin: 0;
  padding: 0;
  display: inline-block;
  vertical-align: middle;
}

.breadcrumb-console-toggle.active .console-arrow {
  transform: rotate(180deg);
}

/* === CONSOLE PANEL === */
.console-panel {
  position: absolute;
  top: 100%;
  right: 2rem;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(20px);
  border-radius: 12px;
  padding: 1rem;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 300;
  border: 1px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.console-panel.open {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

.console-buttons {
  display: flex;
  gap: 0.8rem;
  flex-wrap: wrap;
}

.console-btn {
  background: transparent;
  border: 2px solid var(--ice-cyan);
  color: var(--ice-cyan);
  padding: 0.6rem 1.2rem;
  border-radius: 25px;
  font-size: 0.8rem;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  white-space: nowrap;
}

.console-btn:hover {
  background: var(--ice-cyan);
  color: #000;
  transform: translateY(-2px);
}

.console-btn.frozen {
  border-color: #ff6b6b;
  color: #ff6b6b;
}

.console-btn.frozen:hover {
  background: #ff6b6b;
  color: white;
}

.console-btn.active {
  background: var(--glacier-blue);
  color: #000;
  border-color: var(--glacier-blue);
}

/* Tooltip per console buttons */
.console-btn .tooltip {
  position: absolute;
  bottom: 140%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.95);
  color: white;
  padding: 0.8rem 1rem;
  border-radius: 8px;
  font-size: 0.75rem;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  z-index: 1000;
  border: 1px solid rgba(255, 255, 255, 0.2);
  pointer-events: none;
  min-width: 200px;
  text-align: center;
  line-height: 1.4;
}

.console-btn .tooltip:before {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: rgba(0, 0, 0, 0.95);
}

.console-btn:hover .tooltip {
  opacity: 1;
  visibility: visible;
  transform: translateX(-50%) translateY(-8px);
}

/* Responsive SubHero */
@media (max-width: 768px) {
  .subhero {
    min-height: 60vh; /* Aumentato per consistenza con ABOUT mobile */
    padding: 2rem 1rem 3rem 1rem; /* Aumentato padding-bottom anche su mobile */
    font-size: 1rem;
  }
  .subhero-title {
    font-size: 1.5rem;
  }
  .subhero-subtitle {
    font-size: 1rem;
  }
  
  /* Subhero CTA Responsive */
  .subhero-cta {
    margin-top: 2rem;
  }
  
  .cta-divider {
    width: 40px;
    margin-bottom: 1rem;
  }
  
  .subhero-cta-text {
    font-size: 1rem;
    margin-bottom: 1.5rem;
    padding: 0 1rem;
    line-height: 1.4;
  }
  
  .subhero-join-btn {
    padding: 1rem 2.5rem;
    font-size: 1rem;
    gap: 0.6rem;
    width: auto;
    max-width: 280px;
  }
  
  .btn-icon {
    font-size: 1.1rem;
  }
  
  .btn-arrow {
    font-size: 0.9rem;
  }
}


@media (max-width: 768px) {
  
  .hero-titles-wrapper {
    position: fixed !important; /* Usa fixed invece di absolute su mobile */
    bottom: 20vh !important; /* Posiziona i titoli nel 20% inferiore dello schermo */
    left: 50% !important;
    transform: translateX(-50%) !important;
    z-index: 15 !important; /* Sopra l'iceberg che ha z-index 10 */
    width: 90% !important; /* Limita la larghezza per mobile */
  }
  
  .hero-h1, .hero-h2, .hero-h3 {
    font-size: clamp(1.5rem, 4vw, 3rem); /* Responsive font size */
  }
  }


 





  </style>

</head>




















<body>
  <canvas id="penguin-canvas" width="1000" height="1000"></canvas>
<div id="preloader">
<div class="logo logotype preloader-logo">
  <img src="images/logo/logotext.svg" alt="Logo">
</div>

<div class="spinner"></div>
<p style="color: white; font-size: 1.1rem; margin-bottom: 1rem; text-align: center;">
  Craft your iceberg before diving in
</p>
  <div class="preloader-controls">
    <label>
      Nodes
      <input type="range" id="nodesRange" min="15" max="300" value="15">
      <span id="nodesValue">15</span>
    </label>
    <label>
      Line Distance
      <input type="range" id="distanceRange" min="250" max="550" value="200">
      <span id="distanceValue">200</span>
    </label>
    <button id="startBtn">DIVE IN</button>

  </div>
  
</div>
  <canvas id="particles-background"></canvas>

<!-- Breadcrumb Progress Bar -->
<div class="breadcrumb-container" id="breadcrumbContainer">
  <div class="breadcrumb-progress" id="breadcrumbProgress"></div>
  <div class="breadcrumb-sections">
    <div class="breadcrumb-item active" data-section="hero">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">HOME</span>
    </div>
    <div class="breadcrumb-item" data-section="about">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">ABOUT</span>
    </div>
    <div class="breadcrumb-item" data-section="projects">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">PROJECTS</span>
    </div>
    <div class="breadcrumb-item" data-section="team">
      <span class="breadcrumb-dot"></span>
      <span class="breadcrumb-label">TEAM</span>
    </div>
    <!-- Console Menu Toggle -->
    <div class="breadcrumb-console-toggle" id="consoleToggle">
      <span class="console-label">CONSOLE</span>
      <span class="console-arrow">▼</span>
    </div>
  </div>
  
  <!-- Console Panel Expandable -->
  <div class="console-panel" id="consolePanel">
    <div class="console-buttons">
      <button id="breadcrumbColorToggle" class="console-btn">
        SYNAPSE
        <div class="tooltip">
          Controls the iceberg's dynamic color palette.<br>
          <strong>SYNAPSE</strong> → <strong>FOCUS</strong> → <strong>LET IT FLOW</strong>
        </div>
      </button>
      <button id="breadcrumbClarityToggle" class="console-btn">
        CLARITY
        <div class="tooltip">
          High contrast mode for better readability.<br>
          Black background with white text.
        </div>
      </button>
      <button id="breadcrumbSystemToggle" class="console-btn">
        SYSTEM
        <div class="tooltip">
          Advanced controls panel.<br>
          Developer tools, user preferences, and system settings.
        </div>
      </button>
    </div>
  </div>
</div>

<header class="main-menu">
  <nav>
    <div class="wordcanvas">
      <span class="word" data-target="ABOUT">ABOUT</span>
      <span class="word" data-target="PROJECTS">PROJECTS</span>
      <span class="word" data-target="#BLOG">BLOG</span>
      <span class="word" data-target="TEAM">TEAM</span>
      
      <div class="console-container">
        <div class="console-label">CONSOLE</div>
        <div class="console-buttons">
          <button id="colorToggle" class="color-toggle-btn">
            SYNAPSE
            <div class="tooltip">
              Controls the iceberg's dynamic color palette.<br>
              <strong>SYNAPSE</strong> → <strong>FOCUS</strong> → <strong>LET IT FLOW</strong>
            </div>
          </button>
          <button id="clarityToggle" class="color-toggle-btn">
            CLARITY
            <div class="tooltip">
              High contrast mode for better readability.<br>
              Black background with white text.
            </div>
          </button>
          <button id="systemToggle" class="color-toggle-btn">
            SYSTEM
            <div class="tooltip">
              Advanced controls panel.<br>
              Developer tools, user preferences, and system settings.
            </div>
          </button>
        </div>
      </div>
      
      <!-- CTA JOIN US -->
      <button class="join-us-cta" id="joinUsCta">JOIN US</button>
      
      <!-- Menu Hamburger (visibile solo su mobile) -->
      <div class="hamburger-menu" id="hamburgerMenu">
        <div class="hamburger-line"></div>
        <div class="hamburger-line"></div>
        <div class="hamburger-line"></div>
      </div>
    </div>

      <!-- Advanced System Panel -->
      <div id="systemPanel" class="system-panel">
        <div class="system-panel-header">
          <span class="system-panel-title">SYSTEM CONTROLS</span>
          <button id="closePanelBtn" class="close-panel-btn">×</button>
        </div>
        
        <div class="system-panel-content">
          <!-- Content Management -->
          <div class="control-section">
            <h4>Content Management</h4>
            <div class="control-group">
              <button class="system-btn" id="editBtn">EDIT</button>
              <button class="system-btn" id="previewBtn">PREVIEW</button>
              <button class="system-btn" id="publishBtn">PUBLISH</button>
            </div>
          </div>

          <!-- Developer Tools -->
          <div class="control-section">
            <h4>Developer Tools</h4>
            <div class="control-group">
              <button class="system-btn" id="debugBtn">DEBUG</button>
              <button class="system-btn" id="gridBtn">GRID</button>
              <button class="system-btn" id="traceBtn">TRACE</button>
            </div>
          </div>

          <!-- User Preferences -->
          <div class="control-section">
            <h4>User Preferences</h4>
            <div class="control-group">
              <div class="slider-control">
                <label for="flowSlider">FLOW <span id="flowValue">Normal</span></label>
                <input type="range" id="flowSlider" min="1" max="3" value="2">
              </div>
              <div class="slider-control">
                <label for="depthSlider">DEPTH <span id="depthValue">15</span></label>
                <input type="range" id="depthSlider" min="15" max="300" value="15">
              </div>
              <div class="slider-control">
                <label for="neuralSlider">NEURAL <span id="neuralValue">On</span></label>
                <input type="range" id="neuralSlider" min="0" max="1" value="1">
              </div>
            </div>
            <div class="control-group">
              <button class="system-btn" id="profileBtn">PROFILE</button>
              <button class="system-btn" id="resetBtn">RESET</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>

<!-- Menu Mobile Overlay -->
<div class="mobile-menu-overlay" id="mobileMenuOverlay">
  <!-- X per chiudere il menu -->
  <div class="mobile-close-btn" id="mobileCloseBtn">×</div>
  
  <div class="mobile-nav-items">
    <span class="word" data-target="ABOUT">ABOUT</span>
    <span class="word" data-target="PROJECTS">PROJECTS</span>
    <span class="word" data-target="#BLOG">BLOG</span>
    <span class="word" data-target="TEAM">TEAM</span>
  </div>
  
  <div class="mobile-console-container">
    <div class="console-label">CONSOLE</div>
    <div class="console-buttons">
      <button id="mobileColorToggle" class="color-toggle-btn">
        SYNAPSE
      </button>
      <button id="mobileClarityToggle" class="color-toggle-btn">
        CLARITY
      </button>
      <!-- SYSTEM button rimosso su mobile -->
    </div>
  </div>
  
  <!-- CTA JOIN US per mobile -->
  <div class="mobile-cta-container">
    <button class="mobile-join-us-cta" id="mobileJoinUsCta">JOIN US</button>
  </div>
</div>



  <class="hero" id="hero">
    <canvas id="iceberg" class="hero-canvas"></canvas>
  <div class="hero-text-wrapper">
<div class="hero-text-wrapper">
  <div class="hero-text text-compose mobile-no-text-compose">DEPTH<br>is not a feature. is our<br>NATURE</div>
  <div class="hero-text text-compose mobile-no-text-compose"><strong>AI</strong>CEBERG<br>MIND</div>
</div>

    <div class="horizon-line"></div>
    <div class="scroll-indicator">
      <div class="scroll-box"></div>
      <div class="scroll-text">DIVE IN</div>
    </div>
    
    <!-- CTA JOIN US in Hero -->
    <div class="hero-cta" id="heroCta">
      <button class="hero-join-btn">JOIN US</button>
    </div>
</div>


<!-- SubHero Section -->
<section class="parallax-section subhero" id="subhero">
<div class="subhero-container">
  <div class="dynamic-border">
    <h2 class="subhero-title text-compose mobile-no-text-compose">
      <strong>EMPOWERING HUMANS</strong>
    </h2>
    <h3 class="subhero-subtitle text-compose mobile-no-text-compose">
      through playful education, creative content<br>
      Inspired by science, crafted by AI
    </h3>
    
    <!-- CTA Section -->
    <div class="subhero-cta">
      <div class="cta-divider"></div>
      <p class="subhero-cta-text">What lies beneath the surface of your thinking?</p>
      <button class="subhero-join-btn">
        DIVE DEEPER
        <span class="btn-arrow">→</span>
      </button>
    </div>
  </div>
</div>
</section>


<!-- ABOUT -->
<section class="parallax-section" id="about">
  <!-- Header -->
  <div class="section-header">
    <h2 class="section-title text-compose">BEHIND THE SURFACE</h2>
    <p class="section-subtitle text-compose">Where depth meets discovery, and thinking becomes an art</p>
  </div>

  <div class="flex-2col">
    <div class="content-column">
      <h1 class>AIceberg Mind is a deep dive into the joy of discovery and the beauty of thinking.</h1>
      <h2 class="parallax-text">from the earliest spark to the lifelong wonder of the mind.</h2>
    </div>
    <div class="image-column">
      <img src="images/image_placeholder_about.png" alt="Img 1" class="parallax-image image1" />
    </div>
  </div>

  <div class="flex-full">
    <h3 class="parallax-text">
      It's a space where science meets imagination, where learning becomes play, and where artificial intelligence helps reveal what lies beneath <br>
      the surface — <strong>not by teaching what to think, but by opening paths to think differently</strong>.
    </h3>
    <div class="divider-dots"></div>

    <!-- Manifesto con Read More -->
    <h3 class="text-compose parallax-text"><strong>- a short manifesto</strong></h3>

    <div class="read-more-container" id="readMoreSection">
      <!-- Testo preview sempre visibile (prime tre righe) -->
      <p class="read-more-preview">
        AIceberg Mind was born from a simple belief: that intelligence is not a race to the top, but a journey below the surface. In a world flooded with fast content and noisy knowledge, we wanted to create something different.<br><br>

        We see content not as a product, but as a living experience — one that can play, teach, surprise, and empower. We create digital objects: some playful, some poetic, some purely practical.<br><br>

        We don't claim expertise in psychology or nervous system science. What we claim is curiosity in subconscious rewiring, craftsmanship, and care.
      </p>

      <!-- Contenuto completo nascosto inizialmente -->
      <div class="read-more-content"  id="readMoreContent">
        <p class="read-more-text">
          We are designers, makers, researchers, and parents — trying to shape tools that spark ideas, facilitate creation, or gently awaken minds.<br><br>

          Some of our content is designed for children. Some for adults. Some for both. But all of it is guided by the same principle: explore below the surface. Education is not always the goal — but it's often the side effect. And so is joy.<br><br>

          Inspired by the iceberg, our craft is layered: playful on the surface, rooted in research below. We use AI to enhance form and interaction, but never to replace thought.<br><br>

          Our vision begins in early childhood, where so much is silently shaped — but it doesn't end there. It reaches the child within us all, the parents who guide, the educators who nurture, and the minds that still wonder.<br><br>

          AIceberg Mind is not an answer. It's a question: what kind of world do we create when we shape content from the depth of human potential?
        </p>
      </div>

      <!-- Pulsante Read More -->
      <button class="read-more-btn" id="readMoreBtn">
        <span class="read-more-text">Read more</span>
        <span class="read-less-text" style="display: none;">Read less</span>
      </button>
    </div>
  </div>

  <!-- Vision and Co -->
<div class="horizontal-scroll-wrapper" id="about-cards">
  <div class="horizontal-scroll-content">

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Vision</div>
        <div class="card-content parallax-text">
          <p>Our vision is to shape content that inspires curiosity, reflection, and wonder — creating tools that help people think deeply, not just quickly. We believe that in a world of fast answers, slow thinking is radical.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Mission</div>
        <div class="card-content parallax-text">
          <p>Our mission is to create tools, objects, and experiences that stimulate creative thinking and emotional engagement. We make content that opens doors, not boxes — playful in form, purposeful in intent.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">Approach</div>
        <div class="card-content parallax-text">
          <p>We follow a design-driven, research-inspired process rooted in play and purpose. We mix cognitive science, storytelling, and interactivity — always experimenting, always questioning, never boring.</p>
        </div>
      </div>
    </div>

    <div class="card-scroll">
      <div class="flex-2col-scroll">
        <div class="card-title parallax-text">The AIceberg Method</div>
        <div class="card-content parallax-text">
          <p>Our method is layered: intuitive on the surface, rigorous underneath. Just like an iceberg, most of the structure is hidden — what you see is playful, what you uncover is deep. We reveal how things work, not just what they are.</p>
        </div>
      </div>
    </div>

  </div>
 </div>
</section>

<!-- PROJECTS -->
<section class="parallax-section" id="projects">
  <div class="parallax-bg">
    <img src="images/projects-bg.jpg" alt="Projects Background" class="parallax-image" />
  </div>
  
  <div class="projects-content">
    <!-- Header -->
    <div class="section-header">
      <h2 class="section-title text-compose">OUR LIVING PROJECTS</h2>
      <p class="section-subtitle text-compose">Each project is a seed: interactive, alive.</p>
    </div>
    
    <!-- Horizontal Scroll Container -->
    <div class="horizontal-scroll-wrapper projects-wrapper">
      <div class="horizontal-scroll-content projects-grid">
        
        <!-- Project Card 1: Audio Rituals -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Audio Rituals</h3>
            <p class="project-subtitle">Evening hypnosis for deep rest</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 60%"></div>
            </div>
            <span class="progress-text">60% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
        <!-- Project Card 2: Nursery Rhymes -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Nursery Rhymes</h3>
            <p class="project-subtitle">Educational rhymes with Lumi & Nova</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 50%"></div>
            </div>
            <span class="progress-text">50% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
        <!-- Project Card 3: Specialized Channels -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Specialized Channels</h3>
            <p class="project-subtitle">Mindfulness, history & subconscious</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 90%"></div>
            </div>
            <span class="progress-text">90% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
        <!-- Project Card 4: Birth Prep Program -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Birth Prep Program</h3>
            <p class="project-subtitle">Holistic care for expectant families</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 50%"></div>
            </div>
            <span class="progress-text">50% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
        <!-- Project Card 5: Family Finance Ed -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Family Finance Ed.</h3>
            <p class="project-subtitle">Playful tools for conscious money</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 75%"></div>
            </div>
            <span class="progress-text">75% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
        <!-- Project Card 6: Parent 360 App -->
        <div class="project-card">
          <div class="project-header">
            <h3 class="project-title">Parent 360 App</h3>
            <p class="project-subtitle">All-in-one parenting toolkit</p>
          </div>
          <div class="project-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 30%"></div>
            </div>
            <span class="progress-text">30% Dev</span>
          </div>
          <button class="project-btn">View →</button>
        </div>
        
      </div>
    </div>
  </div>
</section>


<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
<script>
gsap.registerPlugin(ScrollTrigger);

// Horizontal scroll per la sezione ABOUT
gsap.to("#about .horizontal-scroll-content", {
  x: () => -(document.querySelector("#about .horizontal-scroll-content").scrollWidth - window.innerWidth),
  ease: "none",
  scrollTrigger: {
    trigger: "#about .horizontal-scroll-wrapper",
    start: "top top",
    end: () => "+=" + (document.querySelector("#about .horizontal-scroll-content").scrollWidth - window.innerWidth),
    scrub: true,
    pin: true,
    anticipatePin: 1
  }
});

// Horizontal scroll per la sezione PROJECTS
gsap.to("#projects .horizontal-scroll-content", {
  x: () => -(document.querySelector("#projects .horizontal-scroll-content").scrollWidth - window.innerWidth),
  ease: "none",
  scrollTrigger: {
    trigger: "#projects .horizontal-scroll-wrapper",
    start: "top top",
    end: () => "+=" + (document.querySelector("#projects .horizontal-scroll-content").scrollWidth - window.innerWidth),
    scrub: true,
    pin: true,
    anticipatePin: 1
  }
});

// Animazioni per le project cards
gsap.fromTo(".project-card", {
  y: 50,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 0.8,
  stagger: 0.2,
  scrollTrigger: {
    trigger: ".projects-grid",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

// Animazione per il titolo della sezione
gsap.fromTo(".section-title", {
  y: 30,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1,
  scrollTrigger: {
    trigger: ".section-header",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

// Animazioni parallax per SUBHERO
gsap.fromTo(".subhero-title", {
  y: 50,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1.2,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 80%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

gsap.fromTo(".subhero-subtitle", {
  y: 40,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 1,
  delay: 0.3,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 75%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});

gsap.fromTo(".subhero-cta", {
  y: 30,
  opacity: 0
}, {
  y: 0,
  opacity: 1,
  duration: 0.8,
  delay: 0.6,
  ease: "power3.out",
  scrollTrigger: {
    trigger: "#subhero",
    start: "top 70%",
    end: "bottom 20%",
    toggleActions: "play none none reverse"
  }
});
</script>













<script>
  let scrollScale = 1;
  let bgTransitionProgress = 1;
  let numPoints = 15;
  let lineDistance = 500;
  let points = [];

  const canvas = document.getElementById("iceberg");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function generatePoints() {
    points = [];
    const radius = Math.min(canvas.width, canvas.height) / 4;
    for (let i = 0; i < numPoints; i++) {
      const angle = (Math.PI * 2 * i) / numPoints;
      const x = Math.cos(angle) * radius * (0.5 + Math.random());
      const y = Math.sin(angle) * radius * (0.5 + Math.random());
      points.push({ x, y });
    }
  }

  function initPage() {
    resizeCanvas();
    generatePoints();

    document.getElementById("nodesRange").addEventListener("input", (e) => {
      numPoints = parseInt(e.target.value);
      document.getElementById("nodesValue").textContent = numPoints;
      generatePoints();
    });

    document.getElementById("distanceRange").addEventListener("input", (e) => {
      lineDistance = parseInt(e.target.value);
      document.getElementById("distanceValue").textContent = lineDistance;
    });

    document.getElementById("startBtn").addEventListener("click", () => {
      const preloader = document.getElementById("preloader");
      preloader.classList.add("fade-out");
      setTimeout(() => preloader.remove(), 600);
      document.getElementById("penguin-canvas").style.display = "block";
      requestAnimationFrame(draw);
    });

    // === CONTROLLO CICLO COLORI ===
    const colorToggleBtn = document.getElementById("colorToggle");
    if (colorToggleBtn) {
      // Testi per gli stati del pulsante
      const texts = {
        active: "SYNAPSE",
        hover: "FOCUS", 
        frozen: "LET IT FLOW"
      };
      
      // Gestione tooltip su mobile con touch
      let tooltipTimeout;
      
      // Touch devices: mostra tooltip temporaneamente
      colorToggleBtn.addEventListener("touchstart", (e) => {
        if (window.innerWidth <= 768) {
          e.preventDefault();
          const tooltip = colorToggleBtn.querySelector('.tooltip');
          if (tooltip) {
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
            
            clearTimeout(tooltipTimeout);
            tooltipTimeout = setTimeout(() => {
              tooltip.style.opacity = '0';
              tooltip.style.visibility = 'hidden';
            }, 3000);
          }
        }
      });
      
      // Gestione hover desktop - cambia solo il testo, non il tooltip
      colorToggleBtn.addEventListener("mouseenter", () => {
        if (colorCycleActive && window.innerWidth > 768) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.hover}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        }
      });
      
      colorToggleBtn.addEventListener("mouseleave", () => {
        if (colorCycleActive && window.innerWidth > 768) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.active}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        } else if (!colorCycleActive) {
          const currentTooltip = colorToggleBtn.querySelector('.tooltip');
          colorToggleBtn.innerHTML = `${texts.frozen}${currentTooltip ? currentTooltip.outerHTML : ''}`;
        }
      });
      
      // Gestione click
      colorToggleBtn.addEventListener("click", () => {
        colorCycleActive = !colorCycleActive;
        
        if (colorCycleActive) {
          colorToggleBtn.innerHTML = `${texts.active}<div class="tooltip">Controls the iceberg's dynamic color palette.<br><strong>SYNAPSE</strong> → <strong>FOCUS</strong> → <strong>LET IT FLOW</strong></div>`;
          colorToggleBtn.classList.remove("frozen");
          startColorCycle();
        } else {
          colorToggleBtn.innerHTML = `${texts.frozen}<div class="tooltip">Color cycle paused.<br>Click to resume the flow.</div>`;
          colorToggleBtn.classList.add("frozen");
          stopColorCycle();
        }
      });
    }

    // === CONTROLLO MODALITÀ CLARITY ===
    const clarityToggleBtn = document.getElementById("clarityToggle");
    let clarityModeActive = false;
    
    if (clarityToggleBtn) {
      // Gestione tooltip su mobile con touch
      let clarityTooltipTimeout;
      
      // Touch devices: mostra tooltip temporaneamente
      clarityToggleBtn.addEventListener("touchstart", (e) => {
        if (window.innerWidth <= 768) {
          e.preventDefault();
          const tooltip = clarityToggleBtn.querySelector('.tooltip');
          if (tooltip) {
            tooltip.style.opacity = '1';
            tooltip.style.visibility = 'visible';
            
            clearTimeout(clarityTooltipTimeout);
            clarityTooltipTimeout = setTimeout(() => {
              tooltip.style.opacity = '0';
              tooltip.style.visibility = 'hidden';
            }, 3000);
          }
        }
      });
      
      // Gestione click per attivare/disattivare modalità high contrast
      clarityToggleBtn.addEventListener("click", () => {
        clarityModeActive = !clarityModeActive;
        
        if (clarityModeActive) {
          // Attiva modalità high contrast
          document.body.classList.add('high-contrast');
          clarityToggleBtn.classList.add('active');
          clarityToggleBtn.innerHTML = `CLARITY<div class="tooltip">High contrast mode active.<br>Click to return to normal view.</div>`;
          
          // Salva preferenza
          localStorage.setItem('clarityMode', 'true');
        } else {
          // Disattiva modalità high contrast
          document.body.classList.remove('high-contrast');
          clarityToggleBtn.classList.remove('active');
          clarityToggleBtn.innerHTML = `CLARITY<div class="tooltip">High contrast mode for better readability.<br>Black background with white text.</div>`;
          
          // Rimuovi preferenza
          localStorage.removeItem('clarityMode');
        }
      });
      
      // Carica preferenza salvata
      if (localStorage.getItem('clarityMode') === 'true') {
        clarityToggleBtn.click();
      }
    }

    // === CONTROLLO PANNELLO SYSTEM ===
    const systemToggleBtn = document.getElementById("systemToggle");
    const systemPanel = document.getElementById("systemPanel");
    const closePanelBtn = document.getElementById("closePanelBtn");
    let systemPanelOpen = false;

    if (systemToggleBtn && systemPanel) {
      // Gestione apertura/chiusura pannello
      systemToggleBtn.addEventListener("click", () => {
        systemPanelOpen = !systemPanelOpen;
        
        if (systemPanelOpen) {
          systemPanel.classList.add('open');
          systemToggleBtn.classList.add('active');
        } else {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
        }
      });

      // Bottone chiusura pannello
      if (closePanelBtn) {
        closePanelBtn.addEventListener("click", () => {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
          systemPanelOpen = false;
        });
      }

      // Chiudi pannello premendo ESC
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && systemPanelOpen) {
          systemPanel.classList.remove('open');
          systemToggleBtn.classList.remove('active');
          systemPanelOpen = false;
        }
      });

      // === CONTROLLI PANNELLO AVANZATO ===
      
      // Slider FLOW (velocità animazioni)
      const flowSlider = document.getElementById("flowSlider");
      const flowValue = document.getElementById("flowValue");
      if (flowSlider && flowValue) {
        flowSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          const speeds = ["Slow", "Normal", "Fast"];
          flowValue.textContent = speeds[value - 1];
          
          // Applica velocità alle animazioni
          const speedMultipliers = [0.5, 1, 2];
          document.documentElement.style.setProperty('--animation-speed', speedMultipliers[value - 1]);
        });
      }

      // Slider DEPTH (complessità iceberg)
      const depthSlider = document.getElementById("depthSlider");
      const depthValue = document.getElementById("depthValue");
      if (depthSlider && depthValue) {
        depthSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          depthValue.textContent = value;
          numPoints = value;
          generatePoints();
        });
      }

      // Slider NEURAL (background particles)
      const neuralSlider = document.getElementById("neuralSlider");
      const neuralValue = document.getElementById("neuralValue");
      if (neuralSlider && neuralValue) {
        neuralSlider.addEventListener("input", (e) => {
          const value = parseInt(e.target.value);
          neuralValue.textContent = value ? "On" : "Off";
          
          const particlesCanvas = document.getElementById("particles-background");
          if (particlesCanvas) {
            particlesCanvas.style.display = value ? "block" : "none";
          }
        });
      }

      // Pulsanti del pannello
      const buttons = {
        debug: document.getElementById("debugBtn"),
        grid: document.getElementById("gridBtn"),
        trace: document.getElementById("traceBtn"),
        edit: document.getElementById("editBtn"),
        preview: document.getElementById("previewBtn"),
        publish: document.getElementById("publishBtn"),
        profile: document.getElementById("profileBtn"),
        reset: document.getElementById("resetBtn")
      };

      // Gestione pulsanti toggle
      Object.entries(buttons).forEach(([key, btn]) => {
        if (btn) {
          btn.addEventListener("click", () => {
            btn.classList.toggle('active');
            
            // Logica specifica per ogni pulsante
            switch(key) {
              case 'debug':
                // Mostra/nascondi info debug
                console.log('Debug mode:', btn.classList.contains('active'));
                break;
              case 'grid':
                // Mostra/nascondi griglia
                document.body.classList.toggle('dev-grid', btn.classList.contains('active'));
                break;
              case 'trace':
                // Abilita/disabilita trace mouse
                console.log('Trace mode:', btn.classList.contains('active'));
                break;
              case 'reset':
                // Reset tutte le impostazioni
                if (confirm('Reset all settings to default?')) {
                  location.reload();
                }
                break;
              default:
                console.log(`${key} button clicked`);
            }
          });
        }
      });
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPage);
  } else {
    initPage();
  }
</script>

<script>
function updateSectionsColor(currentBg, currentTextColor, interpolatedColor) {
  // Non aggiornare colori se la modalità high contrast è attiva
  if (document.body.classList.contains('high-contrast')) {
    return;
  }
  
  // Aggiorna sfondi e colori delle sezioni
  document.querySelectorAll('.section, .parallax-section').forEach(section => {
    section.style.background = currentBg;
    section.style.color = currentTextColor;
  });
  
  const subhero = document.querySelector('.subhero');
  if (subhero) {
    subhero.style.background = currentBg;
    subhero.style.color = currentTextColor;
  }

  // Aggiorna colori dinamici per H1, H2, H3 globali
  document.querySelectorAll('h1, h2, h3').forEach(title => {
    title.style.color = currentTextColor;
  });
  
  // Aggiorna colori dinamici per tutte le tagline
  document.querySelectorAll('.tagline').forEach(tagline => {
    tagline.style.color = currentTextColor;
  });
  
  // Aggiorna colori dinamici del pulsante SYNAPSE
  const colorToggleBtn = document.getElementById("colorToggle");
  if (colorToggleBtn && !colorToggleBtn.classList.contains('frozen')) {
    // Usa il colore di sfondo dell'iceberg per il bordo e testo
    const icebergBgColor = interpolatedColor || currentBg;
    colorToggleBtn.style.borderColor = icebergBgColor;
    colorToggleBtn.style.color = icebergBgColor;
    
    // Salva i colori per gli eventi hover
    colorToggleBtn.dataset.icebergBg = icebergBgColor;
    colorToggleBtn.dataset.icebergText = currentTextColor;
  }

  // Aggiorna il bordo dinamico 
  const border = document.querySelector('.dynamic-border');
  if (border) {
    border.style.borderColor = interpolatedColor || currentBg;
  }

  // Aggiorna i colori del breadcrumb
  const breadcrumbDots = document.querySelectorAll('.breadcrumb-dot');
  const breadcrumbProgress = document.getElementById('breadcrumbProgress');
  if (breadcrumbDots.length && breadcrumbProgress) {
    breadcrumbDots.forEach(dot => {
      if (!dot.parentElement.classList.contains('active')) {
        dot.style.background = interpolatedColor || currentBg;
      }
    });
    breadcrumbProgress.style.background = interpolatedColor || currentBg;
  }
}
</script>

<!-- Breadcrumb Navigation Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const breadcrumbItems = document.querySelectorAll('.breadcrumb-item');
  const breadcrumbProgress = document.getElementById('breadcrumbProgress');
  
  const sections = [
    { id: 'hero', element: document.getElementById('hero') || document.querySelector('.hero') },
    { id: 'about', element: document.getElementById('about') },
    { id: 'projects', element: document.getElementById('projects') },
    { id: 'team', element: document.getElementById('team') }
  ].filter(section => section.element);

  console.log('🔍 Breadcrumb: Sezioni trovate:', sections.map(s => s.id));
  console.log('🔍 Breadcrumb: Numero sezioni:', sections.length);

  // Funzione per aggiornare breadcrumb attivo
  function updateActiveBreadcrumb(activeIndex) {
    breadcrumbItems.forEach((item, index) => {
      item.classList.toggle('active', index === activeIndex);
    });
    
    // Aggiorna progress bar
    const progressPercent = breadcrumbItems.length > 1 ? (activeIndex / (breadcrumbItems.length - 1)) * 100 : 0;
    breadcrumbProgress.style.width = progressPercent + '%';
  }

  // Intersection Observer per rilevare sezione attiva
  const observerOptions = {
    threshold: 0.3,
    rootMargin: '-20% 0px -20% 0px'
  };

  const sectionObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const sectionIndex = sections.findIndex(section => section.element === entry.target);
        console.log('🎯 Sezione vista:', entry.target.id, 'Index:', sectionIndex);
        if (sectionIndex !== -1) {
          updateActiveBreadcrumb(sectionIndex);
        }
      }
    });
  }, observerOptions);

  // Osserva tutte le sezioni
  sections.forEach(section => {
    sectionObserver.observe(section.element);
  });

  // Click handler per navigazione diretta
  breadcrumbItems.forEach((item, index) => {
    item.addEventListener('click', () => {
      console.log('🖱️ Breadcrumb click su:', item.querySelector('.breadcrumb-label').textContent, 'Index:', index);
      
      // Attiva sempre l'item cliccato
      updateActiveBreadcrumb(index);
      
      // Trova la sezione corrispondente tramite data-section
      const sectionName = item.getAttribute('data-section');
      const sectionElement = document.getElementById(sectionName) || document.querySelector(`.${sectionName}`);
      
      if (sectionElement) {
        sectionElement.scrollIntoView({ 
          behavior: 'smooth',
          block: 'start'
        });
        console.log('📍 Scroll verso:', sectionName);
      } else {
        console.log('⚠️ Sezione non trovata:', sectionName);
      }
    });
  });

  // Inizializza con la prima sezione attiva
  updateActiveBreadcrumb(0);
});
</script>

<!-- Console Toggle Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const consoleToggle = document.getElementById('consoleToggle');
  const consolePanel = document.getElementById('consolePanel');
  
  if (!consoleToggle || !consolePanel) return;

  // Toggle console panel
  consoleToggle.addEventListener('click', () => {
    const isOpen = consolePanel.classList.toggle('open');
    consoleToggle.classList.toggle('active', isOpen);
  });

  // Chiudi panel cliccando fuori
  document.addEventListener('click', (e) => {
    if (!consoleToggle.contains(e.target) && !consolePanel.contains(e.target)) {
      consolePanel.classList.remove('open');
      consoleToggle.classList.remove('active');
    }
  });

  // Replica la logica dei pulsanti console originali
  const breadcrumbColorToggle = document.getElementById('breadcrumbColorToggle');
  const breadcrumbClarityToggle = document.getElementById('breadcrumbClarityToggle');
  const breadcrumbSystemToggle = document.getElementById('breadcrumbSystemToggle');

  // SYNAPSE button logic
  if (breadcrumbColorToggle) {
    breadcrumbColorToggle.addEventListener('click', () => {
      // Replica la logica del pulsante colorToggle originale
      const originalBtn = document.getElementById('colorToggle');
      if (originalBtn) {
        originalBtn.click();
      }
    });
  }

  // CLARITY button logic  
  if (breadcrumbClarityToggle) {
    breadcrumbClarityToggle.addEventListener('click', () => {
      // Replica la logica del pulsante clarityToggle originale
      const originalBtn = document.getElementById('clarityToggle');
      if (originalBtn) {
        originalBtn.click();
      }
    });
  }

  // SYSTEM button logic
  if (breadcrumbSystemToggle) {
    breadcrumbSystemToggle.addEventListener('click', (e) => {
      e.preventDefault();
      console.log('🔧 Breadcrumb SYSTEM clicked');
      
      // Chiudi prima il console panel
      consolePanel.classList.remove('open');
      consoleToggle.classList.remove('active');
      
      // Trova e trigghera il pulsante originale SYSTEM
      const originalSystemBtn = document.getElementById('systemToggle');
      console.log('🔧 Original SYSTEM button found:', !!originalSystemBtn);
      
      if (originalSystemBtn) {
        // Simula un click diretto sul pulsante originale
        originalSystemBtn.click();
        console.log('🔧 Original SYSTEM button clicked');
      }
    });
  }
});
</script>

<!-- Hero CTA Visibility Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  const heroCta = document.getElementById('heroCta');
  if (!heroCta) return;

  let hasScrolled = false;

  function handleScroll() {
    if (!hasScrolled && window.scrollY > 50) {
      hasScrolled = true;
      heroCta.classList.add('visible');
      // Rimuovi il listener dopo il primo scroll
      window.removeEventListener('scroll', handleScroll);
    }
  }

  window.addEventListener('scroll', handleScroll, { passive: true });
});
</script>

<!-- Menu Visibility Control Script -->
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Assicurati che GSAP sia caricato
  if (typeof gsap === 'undefined') return;

  const mainMenu = document.querySelector('.main-menu');
  if (!mainMenu) return;

  // Imposta il menu nascosto inizialmente con GSAP
  gsap.set(mainMenu, {
    y: -100,
    opacity: 0,
    visibility: 'hidden'
  });

  // Anima il menu quando si esce dal subhero
  ScrollTrigger.create({
    trigger: "#subhero",
    start: "bottom 80%", // Quando il fondo del subhero raggiunge l'80% della viewport
    end: "bottom top",
    onEnter: () => {
      gsap.to(mainMenu, {
        y: 0,
        opacity: 1,
        visibility: 'visible',
        duration: 0.8,
        ease: "power2.out"
      });
    },
    onLeaveBack: () => {
      gsap.to(mainMenu, {
        y: -100,
        opacity: 0,
        visibility: 'hidden',
        duration: 0.6,
        ease: "power2.in"
      });
    }
  });
});
</script>


<script>
// === Canvas Setup
window.addEventListener("resize", () => {
  resizeCanvas();
  generatePoints();
});

// === Mouse Tracking
let angleOffset = 0, mouseX = 0, mouseY = 0;
document.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = ((e.clientX - rect.left) / canvas.width - 0.5) * 2;
  mouseY = ((e.clientY - rect.top) / canvas.height - 0.5) * 2;
});

// === Dynamic Color Palette
const dynamicPalette = [
  "#00f5d4", "#3a0ca3", "#4361ee", "#4cc9f0", "#5ee4c3",
  "#f72585", "#7209b7", "#2b2d42", "#edf2f4", "#b5179e"
];
let bgColor = dynamicPalette[0], contrastColor = dynamicPalette[1];
let bgColorOld = bgColor, bgColorNew = contrastColor;
let colorCycleActive = true; // Controllo del ciclo colori
let colorChangeInterval; // Riferimento all'intervallo

function lerpColor(a, b, t) {
  const ah = [1, 3, 5].map(i => parseInt(a.slice(i, i + 2), 16));
  const bh = [1, 3, 5].map(i => parseInt(b.slice(i, i + 2), 16));
  const rh = ah.map((v, i) => Math.round(v + (bh[i] - v) * t).toString(16).padStart(2, '0'));
  return `#${rh.join('')}`;
}

function changeColors() {
  if (!colorCycleActive) return;
  
  const bgIndex = Math.floor(Math.random() * dynamicPalette.length);
  let contrastIndex;
  do { contrastIndex = Math.floor(Math.random() * dynamicPalette.length); }
  while (contrastIndex === bgIndex);

  bgColorOld = bgColor;
  bgColorNew = dynamicPalette[bgIndex];
  bgTransitionProgress = 0;
  bgColor = bgColorNew;
  contrastColor = dynamicPalette[contrastIndex];

  const heroText = document.querySelector(".hero-text");
  if (heroText) heroText.style.color = contrastColor;
}

// Avvia il ciclo colori
function startColorCycle() {
  colorChangeInterval = setInterval(changeColors, 2000);
}

// Ferma il ciclo colori
function stopColorCycle() {
  clearInterval(colorChangeInterval);
}

// Inizializza il ciclo
startColorCycle();

// === Iceberg Drawing
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Modalità high contrast: sfondo nero, iceberg bianco
  if (document.body.classList.contains('high-contrast')) {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    const offsetX = Math.sin(angleOffset) * 20 + mouseX * 30;
    const offsetY = Math.cos(angleOffset) * 20 + mouseY * 30;
    const rotate = Math.sin(angleOffset) * 0.01;
    angleOffset += 0.005;
    
    // Iceberg bianco
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(rotate);
    ctx.scale(scrollScale, scrollScale);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    
    // Riflesso iceberg
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(-rotate);
    ctx.scale(scrollScale, -scrollScale);
    ctx.globalAlpha = 0.3;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 0.5;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  } else {
    // Modalità normale con colori dinamici
    bgTransitionProgress = Math.min(bgTransitionProgress + 0.01, 1);
    const interpolatedColor = lerpColor(bgColorOld, bgColorNew, bgTransitionProgress);
    ctx.fillStyle = interpolatedColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const offsetX = Math.sin(angleOffset) * 20 + mouseX * 30;
    const offsetY = Math.cos(angleOffset) * 20 + mouseY * 30;
    const rotate = Math.sin(angleOffset) * 0.01;
    angleOffset += 0.005;
    
    // Passa sia il background che il colore interpolato per il pulsante
    updateSectionsColor(`linear-gradient(to bottom, ${interpolatedColor}, ${interpolatedColor})`, contrastColor, interpolatedColor);

    // Iceberg top
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(rotate);
    ctx.scale(scrollScale, scrollScale);
    ctx.strokeStyle = contrastColor;
    ctx.lineWidth = 1;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();

    // Iceberg reflection
    ctx.save();
    ctx.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    ctx.rotate(-rotate);
    ctx.scale(scrollScale, -scrollScale);
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = contrastColor;
    for (let i = 0; i < points.length; i++) {
      for (let j = i + 1; j < points.length; j++) {
        const p1 = points[i], p2 = points[j];
        if (Math.hypot(p1.x - p2.x, p1.y - p2.y) < lineDistance) {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
      }
    }
    ctx.restore();
    ctx.globalAlpha = 1;
  }
  
  requestAnimationFrame(draw);
}
</script>

<script>

// === Inizializzazione sistemi nativi ===
document.addEventListener('DOMContentLoaded', () => {
  initNativeHeroEffects();     // 🎯 Hero separato con scroll listener
  initNativeMenuEffects();     // 📱 Menu con Intersection Observer  
  initNativeParallaxEffects(); // 🌊 Sezioni parallax con Intersection Observer
});

// 🎯 HERO SYSTEM - Completamente separato dalla logica parallax
function initNativeHeroEffects() {
  console.log('🚀 Inizializzazione Hero System (separato)');
  
  const heroText = document.querySelector(".hero-text");
  const heroTitles = document.querySelector(".hero-titles-wrapper");
  const hero = document.querySelector(".hero");
  const isMobile = window.innerWidth <= 768;
  
  if (!hero) {
    console.error('❌ Elemento .hero non trovato!');
    return;
  }
  
  console.log(isMobile ? '📱 Hero Mobile mode' : '🖥️ Hero Desktop mode');
  
  let ticking = false;
  
  function handleHeroScroll() {
    if (!ticking) {
      requestAnimationFrame(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const heroHeight = hero.offsetHeight;
        const progress = Math.min(scrollTop / heroHeight, 1);
        
        // 🔍 Zoom iceberg (opzionale - connesso al canvas)
        if (window.scrollScale !== undefined) {
          window.scrollScale = 1 + progress * (isMobile ? 0.1 : 0.3);
        }
        
        // 📝 Animazioni testo hero principale
        if (heroText) {
          heroText.style.opacity = 1 - progress;
          if (!isMobile) {
            heroText.style.transform = `translate(-50%, calc(-50% - ${progress * 80}px))`;
          }
        }
        
        // 🎯 Hero Titles - appaiono quando scroll > 66% dell'hero
        if (heroTitles) {
          const threshold = isMobile ? 0.6 : 0.66;
          if (progress > threshold) {
            const titleOpacity = (progress - threshold) / (1 - threshold);
            heroTitles.style.opacity = titleOpacity;
            if (!isMobile) {
              heroTitles.style.transform = `translate(-50%, calc(-50% + ${(1 - progress) * 30}px))`;
            }
            
            // Debug solo al cambiamento
            if (titleOpacity > 0 && titleOpacity < 0.1) {
              console.log('🎯 Hero Titles SHOW - Progress:', Math.round(progress * 100) + '%');
            }
          } else {
            heroTitles.style.opacity = 0;
            if (progress > 0.5 && progress < 0.6) { // Debug una volta
              console.log('🎯 Hero Titles HIDE - Progress:', Math.round(progress * 100) + '%');
            }
          }
        }
        
        ticking = false;
      });
      ticking = true;
    }
  }
  
  // Listener scroll dedicato SOLO per l'hero
  window.addEventListener('scroll', handleHeroScroll, { passive: true });
  
  // Controllo iniziale
  handleHeroScroll();
  
  console.log('✅ Hero System attivo - Scroll listener dedicato');
}


// === ScrollTrigger NATIVO con Intersection Observer ===
function initNativeMenuEffects() {
  console.log('🔧 Inizializzazione ScrollTrigger nativo...');
  const menu = document.querySelector(".main-menu");
  const subhero = document.querySelector(".subhero");
  
  if (!menu) {
    console.error('❌ Menu .main-menu non trovato!');
    return;
  }
  
  if (!subhero) {
    console.error('❌ Sezione .subhero non trovata!');
    return;
  }

  console.log('✅ Menu e Subhero trovati');
  
  // Stato iniziale: nascosto
  menu.style.opacity = '0';
  menu.style.visibility = 'hidden';
  menu.style.transform = 'translateY(-20px)';
  menu.style.transition = 'opacity 0.3s ease-out, visibility 0.3s ease-out, transform 0.3s ease-out';
  
  let menuVisible = false;
  
  function showMenu() {
    if (!menuVisible) {
      console.log('🔼 Menu SHOW');
      menuVisible = true;
      menu.style.opacity = '1';
      menu.style.visibility = 'visible';
      menu.style.transform = 'translateY(0)';
    }
  }
  
  function hideMenu() {
    if (menuVisible) {
      console.log('🔽 Menu HIDE');
      menuVisible = false;
      menu.style.opacity = '0';
      menu.style.visibility = 'hidden';
      menu.style.transform = 'translateY(-20px)';
    }
  }
  
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      console.log(`📊 Subhero visibility: ${Math.round(entry.intersectionRatio * 100)}%`);

      // Se il subhero è ancora visibile per più del 33% -> nascondi menu
      if (entry.intersectionRatio > 0.33) {
        hideMenu();
      } 
      // Se il hero è quasi completamente fuori vista -> mostra menu
      else if (entry.intersectionRatio <= 0.33) {
        showMenu();
      }
    });
  }, {
    // Osserva quando l'hero entra/esce dal viewport
    threshold: [0, 0.1, 0.2, 0.33, 0.5, 0.66, 0.8, 1.0] // Controlli multipli
  });

  // Inizia a osservare il subhero
  observer.observe(subhero);
  console.log('✅ Intersection Observer attivo sul subhero');

  // FALLBACK: Controllo scroll tradizionale come backup
  let ticking = false;
  function handleScrollBackup() {
    if (!ticking) {
      requestAnimationFrame(() => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const subheroHeight = subhero.offsetHeight;
        const threshold = subheroHeight * 0.66;

        // Log ogni 200px
        if (Math.floor(scrollTop / 200) !== Math.floor((scrollTop - 10) / 200)) {
          console.log(`� BACKUP - Scroll: ${Math.round(scrollTop)}px | Threshold: ${Math.round(threshold)}px`);
        }
        
        ticking = false;
      });
      ticking = true;
    }
  }
  
  window.addEventListener('scroll', handleScrollBackup, { passive: true });
}

// === MENU HAMBURGER CON CSS SEMPLICE ===
document.addEventListener('DOMContentLoaded', function() {
  const hamburgerMenu = document.getElementById('hamburgerMenu');
  const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
  const mobileCloseBtn = document.getElementById('mobileCloseBtn');
  
  if (hamburgerMenu && mobileMenuOverlay) {
    // Funzione per chiudere il menu
    function closeMenu() {
      hamburgerMenu.classList.remove('active');
      mobileMenuOverlay.classList.remove('open');
      // Riabilita scroll della pagina
      document.body.style.overflow = '';
    }
    
    // Funzione per aprire il menu
    function openMenu() {
      hamburgerMenu.classList.add('active');
      mobileMenuOverlay.classList.add('open');
      // Blocca scroll della pagina
      document.body.style.overflow = 'hidden';
    }
    
    // Click sul hamburger per aprire/chiudere menu
    hamburgerMenu.addEventListener('click', function() {
      if (mobileMenuOverlay.classList.contains('open')) {
        closeMenu();
      } else {
        openMenu();
      }
    });

    // Click sulla X per chiudere il menu
    if (mobileCloseBtn) {
      mobileCloseBtn.addEventListener('click', closeMenu);
    }

    // Chiudi menu con tasto ESC
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && mobileMenuOverlay.classList.contains('open')) {
        closeMenu();
      }
    });

    // Previeni scroll della pagina quando si scrolla nel menu
    mobileMenuOverlay.addEventListener('wheel', function(e) {
      e.stopPropagation();
    });

    mobileMenuOverlay.addEventListener('touchmove', function(e) {
      e.stopPropagation();
    });

    // Sincronizza i pulsanti mobile con quelli desktop
    const mobileColorToggle = document.getElementById('mobileColorToggle');
    const mobileClarityToggle = document.getElementById('mobileClarityToggle');

    const desktopColorToggle = document.getElementById('colorToggle');
    const desktopClarityToggle = document.getElementById('clarityToggle');

    // Sincronizza CLARITY button
    if (mobileClarityToggle && desktopClarityToggle) {
      mobileClarityToggle.addEventListener('click', () => {
        desktopClarityToggle.click();
        closeMenu();
      });
    }

    // Sincronizza SYNAPSE button
    if (mobileColorToggle && desktopColorToggle) {
      mobileColorToggle.addEventListener('click', () => {
        desktopColorToggle.click();
        closeMenu();
      });
    }

    // Chiudi menu quando si clicca su un link di navigazione
    const mobileNavItems = document.querySelectorAll('.mobile-nav-items .word');
    mobileNavItems.forEach(item => {
      item.addEventListener('click', closeMenu);
    });

    // Gestione CTA JOIN US mobile
    const mobileJoinUsCta = document.getElementById('mobileJoinUsCta');
    if (mobileJoinUsCta) {
      mobileJoinUsCta.addEventListener('click', () => {
        // Qui puoi aggiungere l'azione per JOIN US (es. aprire form, redirect, etc.)
        console.log('JOIN US clicked from mobile');
        closeMenu();
      });
    }
    
    // Gestione CTA SUBHERO
    const subheroJoinBtn = document.querySelector('.subhero-join-btn');
    if (subheroJoinBtn) {
      subheroJoinBtn.addEventListener('click', () => {
        console.log('🚀 JOIN OUR JOURNEY clicked from SUBHERO');
        
        // Aggiungi effetto visivo
        subheroJoinBtn.style.transform = 'translateY(-3px) scale(0.95)';
        setTimeout(() => {
          subheroJoinBtn.style.transform = '';
        }, 150);
        
        // Qui puoi aggiungere l'azione (es. scroll to contact, open modal, etc.)
        // Per ora mostra un feedback
        showJoinFeedback();
      });
    }
  }
  
  // Funzione feedback per JOIN OUR JOURNEY
  function showJoinFeedback() {
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: var(--ice-cyan);
      padding: 1rem 2rem;
      border-radius: 12px;
      border: 2px solid var(--glacier-blue);
      z-index: 1000;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(20px);
      text-align: center;
      transition: all 0.3s ease;
    `;
    notification.textContent = '🌊 Welcome to the journey! Coming soon...';
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.opacity = '1';
      notification.style.transform = 'translateX(-50%) translateY(0)';
    }, 100);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transform = 'translateX(-50%) translateY(-20px)';
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3000);
  }
});
</script>


<script>
    class NeuralNetwork {
        constructor() {
            this.canvas = document.getElementById('particles-background');
            this.ctx = this.canvas.getContext('2d');
            this.particles = [];
            this.connections = [];
            this.codes = [];
            this.mouse = { x: 0, y: 0 };
            this.animationId = null;

            this.config = {
                particleCount: 80,
                maxDistance: 120,
                particleSize: 3,
                particleSpeed: 0.5,
                connectionOpacity: 0.6,
                pulseSpeed: 0.02,
                codeCount: 15,
                codeSpeed: 0.3,
                colors: {
                    particles: ['#888888', '#999999', '#777777', '#666666', '#aaaaaa','#fff'],
                    connections: '#888888',
                    codes: '#666666'
                }
            };

            this.time = 0;
            this.init();
        }

        init() {
            this.resizeCanvas();
            this.createParticles();
            this.createCodes();
            this.bindEvents();
            this.animate();
        }

        resizeCanvas() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        }

        generateRandomCode() {
            const types = ['binary', 'hex', 'alpha'];
            const type = types[Math.floor(Math.random() * types.length)];

            switch(type) {
                case 'binary':
                    return Array.from({length: 6 + Math.floor(Math.random() * 6)}, () => Math.random() < 0.5 ? '0' : '1').join('');
                case 'hex':
                    const hexChars = '0123456789ABCDEF';
                    return Array.from({length: 4 + Math.floor(Math.random() * 4)}, () => hexChars[Math.floor(Math.random() * hexChars.length)]).join('');
                case 'alpha':
                    const alphaChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                    return Array.from({length: 3 + Math.floor(Math.random() * 4)}, () => alphaChars[Math.floor(Math.random() * alphaChars.length)]).join('');
                default:
                    return '101010';
            }
        }

        createCodes() {
            this.codes = [];
            for (let i = 0; i < this.config.codeCount; i++) {
                this.codes.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * this.config.codeSpeed,
                    vy: (Math.random() - 0.5) * this.config.codeSpeed,
                    text: this.generateRandomCode(),
                    opacity: 0.3 + Math.random() * 0.4,
                    life: 300 + Math.random() * 200,
                    maxLife: 300 + Math.random() * 200,
                    size: 10 + Math.random() * 4
                });
            }
        }

        createParticles() {
            this.particles = [];
            for (let i = 0; i < this.config.particleCount; i++) {
                this.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    vx: (Math.random() - 0.5) * this.config.particleSpeed,
                    vy: (Math.random() - 0.5) * this.config.particleSpeed,
                    size: Math.random() * this.config.particleSize + 1,
                    color: this.config.colors.particles[Math.floor(Math.random() * this.config.colors.particles.length)],
                    pulse: Math.random() * Math.PI * 2,
                    activity: Math.random()
                });
            }
        }

        bindEvents() {
            window.addEventListener('resize', () => {
                this.resizeCanvas();
                this.createParticles();
                this.createCodes();
            });

            this.canvas.addEventListener('mousemove', (e) => {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            });

            this.canvas.addEventListener('mouseleave', () => {
                this.mouse.x = -1000;
                this.mouse.y = -1000;
            });
        }

        updateParticles() {
            this.particles.forEach(particle => {
                // Movimento base
                particle.x += particle.vx;
                particle.y += particle.vy;

                // Effetto mouse
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    const force = (100 - distance) / 100;
                    particle.vx += dx * force * 0.001;
                    particle.vy += dy * force * 0.001;
                    particle.activity = Math.min(1, particle.activity + 0.02);
                } else {
                    particle.activity = Math.max(0, particle.activity - 0.005);
                }

                // Limitazione velocità
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (speed > 2) {
                    particle.vx = (particle.vx / speed) * 2;
                    particle.vy = (particle.vy / speed) * 2;
                }

                // Bordi del canvas
                if (particle.x < 0 || particle.x > this.canvas.width) {
                    particle.vx *= -1;
                    particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
                }
                if (particle.y < 0 || particle.y > this.canvas.height) {
                    particle.vy *= -1;
                    particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
                }

                // Aggiornamento pulsazione
                particle.pulse += this.config.pulseSpeed;
            });
        }

        updateCodes() {
            this.codes.forEach((code, index) => {
                // Movimento
                code.x += code.vx;
                code.y += code.vy;

                // Vita del codice
                code.life--;
                code.opacity = (code.life / code.maxLife) * 0.7;

                // Bordi del canvas
                if (code.x < -50 || code.x > this.canvas.width + 50) {
                    code.vx *= -1;
                }
                if (code.y < -20 || code.y > this.canvas.height + 20) {
                    code.vy *= -1;
                }

                // Rigenera codice se morto
                if (code.life <= 0) {
                    code.x = Math.random() * this.canvas.width;
                    code.y = Math.random() * this.canvas.height;
                    code.text = this.generateRandomCode();
                    code.life = code.maxLife;
                    code.opacity = 0.3 + Math.random() * 0.4;
                }

                // Cambia codice occasionalmente
                if (Math.random() < 0.001) {
                    code.text = this.generateRandomCode();
                }
            });
        }

        drawConnections() {
            this.ctx.strokeStyle = this.config.colors.connections;
            this.ctx.lineWidth = 1;

            for (let i = 0; i < this.particles.length; i++) {
                for (let j = i + 1; j < this.particles.length; j++) {
                    const p1 = this.particles[i];
                    const p2 = this.particles[j];

                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.config.maxDistance) {
                        const opacity = (1 - distance / this.config.maxDistance) * this.config.connectionOpacity;
                        const activity = (p1.activity + p2.activity) / 2;

                        // Effetto pulsazione nelle connessioni
                        const pulse = Math.sin(this.time * 0.01 + distance * 0.01) * 0.3 + 0.7;

                        this.ctx.globalAlpha = opacity * pulse * (0.3 + activity * 0.7);
                        this.ctx.beginPath();
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                        this.ctx.stroke();

                        // Segnali neurali che viaggiano lungo le connessioni
                        if (Math.random() < 0.001 + activity * 0.01) {
                          this.drawNeuralSignal(p1, p2, distance);
                        }
                    }
                }
            }
        }

        drawNeuralSignal(p1, p2, distance) {
            const progress = (this.time * 0.02) % 1;
            const x = p1.x + (p2.x - p1.x) * progress;
            const y = p1.y + (p2.y - p1.y) * progress;

            this.ctx.globalAlpha = Math.sin(progress * Math.PI) * 0.8;
            this.ctx.fillStyle = '#cccccc';
            this.ctx.beginPath();
            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
            this.ctx.fill();
        }

        drawParticles() {
            this.particles.forEach(particle => {
                const pulseScale = 1 + Math.sin(particle.pulse) * 0.3 * particle.activity;
                const size = particle.size * pulseScale;

                // Glow effect grigio
                this.ctx.shadowColor = particle.color;
                this.ctx.shadowBlur = 10 + particle.activity * 15;

                // Corpo principale
                this.ctx.globalAlpha = 0.7 + particle.activity * 0.3;
                this.ctx.fillStyle = particle.color;
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fill();

                // Nucleo leggermente più chiaro
                this.ctx.globalAlpha = 0.9;
                this.ctx.fillStyle = '#bbbbbb';
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size * 0.3, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.shadowBlur = 0;
            });
        }

        drawCodes() {
            this.ctx.font = '12px "Courier New", monospace';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';

            this.codes.forEach(code => {
                this.ctx.globalAlpha = code.opacity;
                this.ctx.fillStyle = this.config.colors.codes;

                // Effetto leggero glow per i codici
                this.ctx.shadowColor = this.config.colors.codes;
                this.ctx.shadowBlur = 5;

                this.ctx.fillText(code.text, code.x, code.y);

                this.ctx.shadowBlur = 0;
            });
        }

        animate() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            this.updateParticles();
            this.updateCodes();
            this.drawConnections();
            this.drawParticles();
            this.drawCodes();

            this.time++;
            this.animationId = requestAnimationFrame(() => this.animate());
        }

        destroy() {
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
            }
            window.removeEventListener('resize', this.resizeCanvas);
            this.canvas.removeEventListener('mousemove', this.mouseMoveHandler);
            this.canvas.removeEventListener('mouseleave', this.mouseLeaveHandler);
        }
    }

    // Inizializzazione
    const neuralNetwork = new NeuralNetwork();

    // Cleanup quando la pagina viene chiusa
    window.addEventListener('beforeunload', () => {
        neuralNetwork.destroy();
    });
</script>

<script>
// ⚡ SEZIONI PARALLAX SYSTEM - Separato dall'Hero
function initNativeParallaxEffects() {
  console.log('🌊 Inizializzazione Parallax System (solo sezioni, NO hero)');
  document.body.style.overflowY = 'auto';
  initParallaxImages();
  initParallaxText();
  initParallaxMovement();
  initParallaxBackgrounds();
}

// 🖼️ Parallax IMMAGINI
function initParallaxImages() {
  const parallaxImages = document.querySelectorAll('.parallax-image:not(.hero .parallax-image), .parallax-section .parallax-image, section:not(.hero) .parallax-image');
  console.log(`🖼️ Parallax: Trovate ${parallaxImages.length} immagini (hero escluso)`);

  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      const progress = entry.intersectionRatio;

      if (entry.isIntersecting) {
        entry.target.classList.add('parallax-active');

        const isMobile = window.innerWidth <= 768;
        const scaleRange = isMobile ? 0.1 : 0.3;
        const yRange = isMobile ? 60 : 100;

        const scale = (isMobile ? 0.6 : 0.5) + (scaleRange * progress);
        const y = (isMobile ? 30 : 50) - (yRange * progress);
        const opacity = 0.2 + (0.8 * progress);

        entry.target.style.transform = `scale(${scale}) translateY(${y}px)`;
        entry.target.style.opacity = opacity;
        entry.target.style.transition = 'transform 0.6s ease-out, opacity 0.6s ease-out';

        if (progress === 1) console.log(`🖼️ Immagine parallax completamente visibile`);
      }
    });
  }, {
    threshold: Array.from({ length: 6 }, (_, i) => i / 5),
    rootMargin: '50px 0px -50px 0px'
  });

  parallaxImages.forEach(image => imageObserver.observe(image));
}

// 📝 Parallax TESTO migliorato
function initParallaxText() {
  const parallaxTexts = document.querySelectorAll(
    '.parallax-text:not(.hero .parallax-text), .parallax-section .parallax-text, section:not(.hero) .parallax-text'
  );
  console.log(`📝 Parallax: Trovati ${parallaxTexts.length} testi (hero escluso)`);

  const textObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      if (entry.isIntersecting && entry.intersectionRatio > 0.15) {
        entry.target.style.opacity = '1';
        entry.target.style.transform = 'translateY(0)';
        textObserver.unobserve(entry.target); // ⬅️ migliora performance
        console.log('📝 Testo parallax attivato');
      }
    });
  }, {
    threshold: 0.15,
    rootMargin: '0px 0px -20% 0px'
  });

  parallaxTexts.forEach(text => {
    // Imposta solo se non già presenti
    if (!text.style.opacity) text.style.opacity = '0';
    if (!text.style.transform) text.style.transform = 'translateY(40px)';
    if (!text.style.transition) text.style.transition = 'opacity 0.8s ease-out, transform 0.8s ease-out';
    textObserver.observe(text);
  });
}


// 🎭 Parallax MOVIMENTO
const activeParallaxImgs = new Set();

function handleGlobalParallaxScroll() {
  activeParallaxImgs.forEach(img => {
    const rect = img.getBoundingClientRect();
    const scrollProgress = (window.innerHeight - rect.top) / (window.innerHeight + rect.height);
    const clampedProgress = Math.max(0, Math.min(1, scrollProgress));
    const yOffset = 100 - (200 * clampedProgress);
    img.style.transform = `translateY(${yOffset}px)`;
  });
}
window.addEventListener('scroll', handleGlobalParallaxScroll, { passive: true });

function initParallaxMovement() {
  const parallaxImgs = document.querySelectorAll('.parallax-img:not(.hero .parallax-img), .parallax-section .parallax-img, section:not(.hero) .parallax-img');
  console.log(`🎭 Parallax: Trovate ${parallaxImgs.length} immagini con movimento (hero escluso)`);

  parallaxImgs.forEach(img => {
    const movementObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.target.closest('.hero')) return;

        if (entry.isIntersecting) {
          activeParallaxImgs.add(entry.target);
          handleGlobalParallaxScroll(); // aggiorna subito
          console.log('🎭 Movimento parallax attivato');
        } else {
          activeParallaxImgs.delete(entry.target);
        }
      });
    }, { threshold: 0.1 });

    movementObserver.observe(img);
  });
}

// 🌈 Parallax SFONDI
function initParallaxBackgrounds() {
  const bgLayers = document.querySelectorAll('.bg-layer:not(.hero .bg-layer), .parallax-section .bg-layer,.bg-layer');
  console.log(`🌈 Parallax: Trovati ${bgLayers.length} sfondi (hero escluso)`);

  const bgObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.target.closest('.hero')) return;

      if (entry.isIntersecting) {
        const progress = entry.intersectionRatio;
        entry.target.style.backgroundPosition = `0% ${progress * 100}%`;
        entry.target.style.transition = 'background-position 0.6s ease-out';

        if (progress === 1) {
          console.log(`🌈 Sfondo parallax completamente attivo`);
        }
      }
    });
  }, {
    threshold: Array.from({ length: 6 }, (_, i) => i / 5)
  });

  bgLayers.forEach(bg => bgObserver.observe(bg));
}
</script>















<!-- ✅ QUESTI SONO GLI UNICI SCRIPT CHE SERVONO -->
<script src="https://cdn.jsdelivr.net/npm/three@0.136.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.136.0/examples/js/controls/OrbitControls.js"></script>

<!-- ✅ TUTTO RACCHIUSO IN UNA FUNZIONE PER EVITARE CONFLITTI CON L'ICEBERG -->
<script>
  document.addEventListener("DOMContentLoaded", () => {
    initPenguinCanvas();
  });

  function rgbToHex(rgb) {
    const result = rgb.match(/\d+/g).map(Number).slice(0, 3);
    return (
      '#' +
      result.map(x => x.toString(16).padStart(2, '0')).join('')
    );
  }

  function enableCanvasDrag(canvas, controlsPenguin) {
    let isDragging = false;
    let offsetX, offsetY;

    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      canvas.classList.add("dragging");
      controlsPenguin.enabled = false; // 🔴 Disabilita Orbit durante il drag

      const rect = canvas.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;

      canvas.style.position = 'fixed';
      canvas.style.left = `${e.clientX - offsetX}px`;
      canvas.style.top = `${e.clientY - offsetY}px`;
      canvas.style.right = 'auto';
      canvas.style.bottom = 'auto';
    });

    document.addEventListener("mouseup", () => {
      isDragging = false;
      canvas.classList.remove("dragging");
      controlsPenguin.enabled = true; // ✅ Riattiva Orbit alla fine del drag
    });
  }

  function initPenguinCanvas() {
    const canvas = document.getElementById("penguin-canvas");
    if (!canvas) {
      console.error("Canvas con id 'penguin-canvas' non trovato!");
      return;
    }

    const dpr = window.devicePixelRatio || 1;
    canvas.width = 1000 * dpr;
    canvas.height = 1000 * dpr;

    const scenePenguin = new THREE.Scene();
    scenePenguin.background = null;

    const aspect = canvas.width / canvas.height;
    const cameraPenguin = new THREE.PerspectiveCamera(60, aspect, 1, 100000);
    cameraPenguin.position.set(500, -300, 1500);
    cameraPenguin.lookAt(500, -300, 0);

    const rendererPenguin = new THREE.WebGLRenderer({
      canvas: canvas,
      antialias: true,
      alpha: true
    });
    rendererPenguin.setClearColor(0x000000, 0);
    rendererPenguin.setSize(600, 500, false);
    rendererPenguin.setPixelRatio(dpr);

    const controlsPenguin = new THREE.OrbitControls(cameraPenguin, rendererPenguin.domElement);
    controlsPenguin.enableZoom = false;
    controlsPenguin.enablePan = true;
    controlsPenguin.minDistance = 800;
    controlsPenguin.maxDistance = 6000;
    controlsPenguin.maxPolarAngle = Math.PI;
    controlsPenguin.minPolarAngle = 0;
    controlsPenguin.target.set(500, -300, -250);
    controlsPenguin.update();

    enableCanvasDrag(canvas, controlsPenguin);

    canvas.addEventListener("mouseenter", () => {
      if (!controlsPenguin.enabled) controlsPenguin.enabled = true;
    });
    canvas.addEventListener("mouseleave", () => {
      if (!canvas.classList.contains("dragging")) {
        controlsPenguin.enabled = false;
      }
    });

    let dynamicMaterial = null;

    fetch('prova.json')
      .then(res => res.json())
      .then(data => {
        const points = data.penguinpoints;
        const edges = data.penguinedges;

        const vertices = [];
        edges.forEach(([start, end]) => {
          const p1 = points[start];
          const p2 = points[end];
          vertices.push(new THREE.Vector3(p1.x, -p1.y, 0));
          vertices.push(new THREE.Vector3(p2.x, -p2.y, 0));
        });

        const geometry = new THREE.BufferGeometry().setFromPoints(vertices);
        dynamicMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const lines = new THREE.LineSegments(geometry, dynamicMaterial);
        scenePenguin.add(lines);
      })
      .catch(err => console.error('Errore caricamento JSON:', err));

    function updateMaterialColorFromHero() {
      const heroText = document.querySelector('.hero-text');
      if (!heroText || !dynamicMaterial) return;

      const color = getComputedStyle(heroText).color;
      const hex = rgbToHex(color);
      if (dynamicMaterial.color.getStyle() !== hex) {
        dynamicMaterial.color.set(hex);
      }
    }

    function animatePenguin() {
      requestAnimationFrame(animatePenguin);
      updateMaterialColorFromHero();
      rendererPenguin.render(scenePenguin, cameraPenguin);
    }

    animatePenguin();
  }
</script>

<!-- ✅ EFFETTO FADE-IN DELLE IMMAGINI PARALLAX CON SCROLL -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Seleziona tutte le immagini parallax nei layout flex
  const parallaxImages = document.querySelectorAll('.flex-2col .parallax-image, .flex-full .parallax-image, .parallax-image, .parallax-image');
  
  // Crea l'Intersection Observer
  const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // Aggiunge la classe in-view quando l'immagine entra in vista
        entry.target.classList.add('in-view');
      }
    });
  }, {
    threshold: 0.3, // Trigger quando il 30% dell'immagine è visibile
    rootMargin: '0px 0px -50px 0px' // Trigger un po' prima che sia completamente visibile
  });
  
  // Osserva tutte le immagini parallax
  parallaxImages.forEach(image => {
    imageObserver.observe(image);
  });
});
</script>

<!-- ✅ EFFETTO COMPOSIZIONE TESTO LETTERA PER LETTERA CON CLASSE CSS -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  
  // Funzione per applicare l'effetto composizione testo
  function applyTextCompositionEffect(element) {
    // Salva il contenuto HTML originale per preservare <br> e altri tag
    const originalHTML = element.innerHTML;
    const originalStyle = window.getComputedStyle(element);
    
    // Evita overflow sui contenitori
    const parent = element.parentElement;
    if (parent) {
      parent.style.overflow = 'hidden';
    }
    
    // Funzione per processare nodi di testo preservando la struttura
    function processTextNode(textNode) {
      const text = textNode.textContent;
      const letters = [];
      
      // Crea span per ogni lettera
      text.split('').forEach((char, index) => {
        const span = document.createElement('span');
        span.textContent = char === ' ' ? '\u00A0' : char; // Preserva spazi
        span.style.display = 'inline-block';
        span.style.position = 'relative';
        span.style.opacity = '0';
        span.style.transform = 'translateX(20px) scale(0.8)'; // 🔥 Ridotto da 50px a 20px
        span.style.transition = `all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
        span.dataset.letterIndex = letters.length; // Indice globale
        letters.push(span);
      });
      
      // Sostituisce il nodo di testo con gli span
      const fragment = document.createDocumentFragment();
      letters.forEach(letter => fragment.appendChild(letter));
      textNode.parentNode.replaceChild(fragment, textNode);
      
      return letters;
    }
    
    // Trova tutti i nodi di testo nell'elemento
    function getTextNodes(node) {
      const textNodes = [];
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        textNodes.push(node);
      } else {
        for (let child of node.childNodes) {
          textNodes.push(...getTextNodes(child));
        }
      }
      return textNodes;
    }
    
    // Processa tutti i nodi di testo
    const textNodes = getTextNodes(element);
    const allLetters = [];
    
    textNodes.forEach(textNode => {
      const letters = processTextNode(textNode);
      allLetters.push(...letters);
    });
    
    // Aggiorna gli indici per l'animazione sequenziale
    allLetters.forEach((letter, globalIndex) => {
      letter.style.transitionDelay = `${globalIndex * 0.03}s`;
      letter.dataset.globalIndex = globalIndex;
    });
    
    // Marca come processato
    element.dataset.textComposition = 'processed';
    
    // Intersection Observer per attivare l'animazione
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          // Ritardo di attivazione per rendere l'effetto più elegante
          setTimeout(() => {
            // Attiva l'animazione delle lettere
            allLetters.forEach((letter, index) => {
              setTimeout(() => {
                letter.style.opacity = '1';
                letter.style.transform = 'translateX(0) scale(1)';
              }, index * 30); // 30ms tra ogni lettera
            });
          }, 300); // Ritardo iniziale di 300ms
          
          // Smette di osservare una volta attivato
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.1, // Attiva quando anche solo il 10% dell'elemento è visibile
      rootMargin: '0px 0px 0px 0px' // Nessun margine - attiva appena è in vista
    });
    
    observer.observe(element);
    
    // CONTROLLO IMMEDIATO: Se l'elemento è già visibile al caricamento, attiva subito
    setTimeout(() => {
      const rect = element.getBoundingClientRect();
      const isVisible = rect.top < window.innerHeight && rect.bottom > 0;
      
      if (isVisible && allLetters.length > 0 && allLetters[0].style.opacity === '0') {
        // Ritardo di attivazione anche per elementi già visibili
        setTimeout(() => {
          // Attiva l'animazione immediatamente
          allLetters.forEach((letter, index) => {
            setTimeout(() => {
              letter.style.opacity = '1';
              letter.style.transform = 'translateX(0) scale(1)';
            }, index * 30);
          });
        }, 500); // Ritardo maggiore per elementi già visibili (hero section)
        observer.unobserve(element);
      }
    }, 200); // Piccolo delay per assicurarsi che il DOM sia pronto
  }
  
  // AUTO-RILEVAMENTO: Cerca automaticamente tutti gli elementi con la classe 'text-compose'
  // ESCLUSI: elementi che hanno 'no-text-compose' o 'mobile-no-text-compose' su mobile
  function initTextComposition() {
    const isMobile = window.innerWidth <= 768;
    let selector = '.text-compose:not(.no-text-compose):not([data-text-composition="processed"])';
    
    // Su mobile, escludi anche gli elementi con 'mobile-no-text-compose'
    if (isMobile) {
      selector = '.text-compose:not(.no-text-compose):not(.mobile-no-text-compose):not([data-text-composition="processed"])';
    }
    
    const textComposeElements = document.querySelectorAll(selector);
    
    textComposeElements.forEach(element => {
      applyTextCompositionEffect(element);
    });
  }
  
  // Avvia il rilevamento automatico
  setTimeout(initTextComposition, 100);
  
  // Espone la funzione globalmente per il riuso
  window.initTextComposition = initTextComposition;
  
  // Funzione globale per applicare manualmente l'effetto (opzionale)
  window.activateTextComposition = function(selectors) {
    if (typeof selectors === 'string') {
      selectors = [selectors];
    }
    
    selectors.forEach(selector => {
      const targetElements = document.querySelectorAll(`${selector}:not([data-text-composition="processed"])`);
      targetElements.forEach(element => {
        applyTextCompositionEffect(element);
      });
    });
  };
});
</script>

<!-- ✅ ACCORDION RIUTILIZZABILE -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Gestione click Read More riutilizzabile
  const readMoreBtn = document.getElementById('readMoreBtn');
  const readMoreContent = document.getElementById('readMoreContent');
  const readMoreText = readMoreBtn?.querySelector('.read-more-text');
  const readLessText = readMoreBtn?.querySelector('.read-less-text');
  
  if (readMoreBtn && readMoreContent) {
    readMoreBtn.addEventListener('click', () => {
      const isOpen = readMoreContent.classList.contains('open');
      
      if (isOpen) {
        // Chiudi: contenuto completo -> solo preview
        readMoreContent.classList.remove('open');
        readMoreText.style.display = 'inline';
        readLessText.style.display = 'none';
      } else {
        // Apri: mostra contenuto completo
        readMoreContent.classList.add('open');
        readMoreText.style.display = 'none';
        readLessText.style.display = 'inline';
        
        // Attiva text-compose sul nuovo contenuto
        setTimeout(() => {
          if (window.initTextComposition) {
            window.initTextComposition();
          }
        }, 400); // Delay per sincronizzarsi con l'animazione
      }
    });
  }
});
</script>

<!-- Project Cards Interaction -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Project cards click handlers
  const projectCards = document.querySelectorAll('.project-card');
  const projectBtns = document.querySelectorAll('.project-btn');
  
  // Add click handlers to project cards
  projectCards.forEach((card, index) => {
    card.addEventListener('click', (e) => {
      // Prevent button click from triggering card click
      if (e.target.classList.contains('project-btn')) {
        return;
      }
      
      const projectTitle = card.querySelector('.project-title').textContent;
      console.log(`🚀 Opening project: ${projectTitle}`);
      
      // Add visual feedback
      card.style.transform = 'scale(0.98)';
      setTimeout(() => {
        card.style.transform = '';
      }, 150);
      
      // Here you could navigate to project page or open modal
      // For now, just log the action
      showProjectInfo(projectTitle);
    });
  });
  
  // Add click handlers to project buttons
  projectBtns.forEach((btn) => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent card click
      
      const card = btn.closest('.project-card');
      const projectTitle = card.querySelector('.project-title').textContent;
      
      console.log(`📋 View details for: ${projectTitle}`);
      
      // Add button animation
      btn.style.transform = 'translateX(10px) scale(1.05)';
      setTimeout(() => {
        btn.style.transform = '';
      }, 200);
      
      showProjectDetails(projectTitle);
    });
  });
  
  // Project info function
  function showProjectInfo(projectName) {
    // Create a simple notification
    const notification = document.createElement('div');
    notification.style.cssText = `
      position: fixed;
      top: 100px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: var(--ice-cyan);
      padding: 1rem 1.5rem;
      border-radius: 8px;
      border: 2px solid var(--glacier-blue);
      z-index: 1000;
      font-size: 0.9rem;
      font-weight: 600;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(20px);
      transition: all 0.3s ease;
    `;
    notification.textContent = `Project: ${projectName} - Coming Soon!`;
    
    document.body.appendChild(notification);
    
    // Animate in
    setTimeout(() => {
      notification.style.transform = 'translateY(0)';
      notification.style.opacity = '1';
    }, 100);
    
    // Remove after 3 seconds
    setTimeout(() => {
      notification.style.transform = 'translateY(-20px)';
      notification.style.opacity = '0';
      setTimeout(() => {
        document.body.removeChild(notification);
      }, 300);
    }, 3000);
  }
  
  // Project details function
  function showProjectDetails(projectName) {
    showProjectInfo(`${projectName} Details`);
  }
  
  // Add hover effects for project cards
  projectCards.forEach((card) => {
    const progressBar = card.querySelector('.progress-fill');
    const originalWidth = progressBar.style.width;
    
    card.addEventListener('mouseenter', () => {
      // Animate progress bar on hover
      progressBar.style.transition = 'width 0.5s ease';
      const currentWidth = parseInt(originalWidth);
      progressBar.style.width = Math.min(currentWidth + 10, 100) + '%';
    });
    
    card.addEventListener('mouseleave', () => {
      // Reset progress bar
      progressBar.style.width = originalWidth;
    });
  });
});
</script>

</body>
</html>
